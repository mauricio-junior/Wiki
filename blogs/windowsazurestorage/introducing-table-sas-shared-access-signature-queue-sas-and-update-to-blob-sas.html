---
layout: windowsazurestorage
title: Introducing Table SAS (Shared Access Signature), Queue SAS and update to Blob SAS
weight: 3
---

<div id="site-content" class="site-content row">

	<div id="primary" class="content-area col-sm-9">
		<div id="single-content" class="div-content">

			
				
<article id="post-83" class="post-83 post type-post status-publish format-standard hentry category-uncategorized">

	<header class="entry-header single">
		<h1 class="entry-title">Introducing Table SAS (Shared Access Signature), Queue SAS and update to Blob SAS</h1>		<div class="rating-wrap">
		<div id="star-rating-83" class="wds-ratings" data-rating="4" data-userrating="0" data-postid="83" data-container="body" data-toggle="tooltip" title="3 user(s) rated">
			<div class="wds-ratings-inner-wrap">
				<div>
					<div aria-label="Select 5 star, this article is 4 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="5"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span><span aria-hidden="true" class="star-4"><span>&#x2605;</span></span><span aria-hidden="true" class="star-5"><span>&#x2605;</span></span></div><div aria-label="Select 4 star, this article is 4 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="4"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span><span aria-hidden="true" class="star-4"><span>&#x2605;</span></span></div><div aria-label="Select 3 star, this article is 4 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="3"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span></div><div aria-label="Select 2 star, this article is 4 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="2"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span></div><div aria-label="Select 1 star, this article is 4 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="1"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span></div>
				</div>
			</div>
		</div>
		</div>		<div class="clear-both"></div>
		<div class="entry-meta">
			<img alt="avatar of windows-azure-storage" src="https://i1.social.s-msft.com/profile/u/avatar.jpg?displayname=Windows+Azure+Storage&amp;size=extralarge&amp;version=00000000-0000-0000-0000-000000000000" class="avatar avatar-22 photo" height="22" width="22"/><span class="byline"><span class="author vcard"><a class="url fn n profile-usercard-hover" data-profile-userid="59e1aedafa2d4428b7004b2c2fac4adc" href="https://social.msdn.microsoft.com/profile/Windows+Azure+Storage">Windows Azure Storage</a></span></span><span class="posted-on posted-on-margin"><span class="screen-reader-text"></span><time class="entry-date published updated" datetime="2012-06-12T08:38:10+00:00">June 12, 2012</time></span><span class="comments-link"><span class="glyphicon glyphicon-comment" aria-hidden="true"></span><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#comments">9</a></span>				<span class="social-icons-wrap">
		<ul class="social-icons">
			<li><div class="fb-share-button" data-href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/" data-layout="button_count" data-size="large" data-mobile-iframe="true"><a class="fb-xfbml-parse-ignore" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/&amp;src=sdkpreparse">Share</a></div></li>
			<div id="fb-root" style="display:none"></div>

			<li class="social-icon twitter"><a data-social="{&quot;type&quot;:&quot;twitter&quot;, &quot;url&quot;:&quot;https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/&quot;, &quot;text&quot;: &quot;Introducing Table SAS (Shared Access Signature), Queue SAS and update to Blob SAS&quot;}" href="#" id="post_tweet_count">0</a></li>
			<li class="social-icon linkedin"><a data-social="{&quot;type&quot;:&quot;linkedin&quot;, &quot;url&quot;:&quot;https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/&quot;, &quot;text&quot;: &quot;Introducing Table SAS (Shared Access Signature), Queue SAS and update to Blob SAS&quot;}" href="#" id="get_post_linkedin_count">0</a></li>
		</ul>
	</span><!-- .social-icons-wrap -->
	<script type="text/javascript">
		// Get social counts
		jQuery( window ).load(function () {
			jQuery.getScript('https://blogs.msdn.microsoft.com/windowsazurestorage/wp-content/themes/microsoft/js/social-counts.js?ver=02092017')
				.done(function(script,textStatus) {
					window.msdnsocial.ajax('https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/');
				});
		});
	</script>
		</div>
		<hr>
	</header><!-- .entry-header -->

	<div class="entry-content single">
		<p><strong>For an overview of Shared Access Signatures please refer to the following </strong><a href="http://azure.microsoft.com/en-us/documentation/articles/storage-dotnet-shared-access-signature-part-1/" target="_blank"><strong>documentations</strong></a><strong>.</strong></p>
<p>We’re excited to announce that, as part of version 2012-02-12, we have introduced Table Shared Access Signatures (SAS), Queue SAS and updates to Blob SAS. In this blog, we will highlight usage scenarios for these new features along with sample code using the Windows Azure Storage Client Library v1.7.1, which is available on <a href="https://github.com/WindowsAzure/azure-sdk-for-net/tree/sdk_1.7.1">GitHub</a>.<a name="_GoBack"></a></p>
<p>Shared Access Signatures allow granular access to tables, queues, blob containers, and blobs. A SAS token can be configured to provide specific access rights, such as read, write, update, delete, etc. to a specific table, key range within a table, queue, blob, or blob container; for a specified time period or without any limit. The SAS token appears as part of the resource’s URI as a series of query parameters. Prior to version 2012-02-12, Shared Access Signature could only grant access to blobs and blob containers.</p>
<h3>SAS Update to Blob in version 2012-02-12</h3>
<p>In the 2012-02-12 version, Blob SAS has been extended to allow unbounded access time to a blob resource instead of the previously limited one hour expiry time for non-revocable SAS tokens. To make use of this additional feature, the <b>sv</b> (signed version) query parameter must be set to &quot;2012-02-12&quot; which would allow the difference between <b>se </b>(signed expiry, which is mandatory) and <b>st</b> (signed start, which is optional) to be larger than one hour. For more details, refer to the <a href="http://go.microsoft.com/fwlink/?LinkId=512473" target="_blank">MSDN documentation</a>.</p>
<h3>Best Practices When Using SAS</h3>
<p>The following are best practices to follow when using Shared Access Signatures.</p>
<ol>
<li><b>Always use HTTPS when making SAS requests.</b> SAS tokens are sent over the wire as part of a URL, and can potentially be leaked if HTTP is used. A leaked SAS token grants access until it either expires or is revoked. </li>
<li><b>Use server stored access policies for revokable SAS.</b> Each container, table, and queue can now have up to five server stored access policies at once. Revoking one of these policies invalidates all SAS tokens issued using that policy. Consider grouping SAS tokens such that logically related tokens share the same server stored access policy. Avoid inadvertently reusing revoked access policy identifiers by including a unique string in them, such as the date and time the policy was created. </li>
<li><b>Don’t specify a start time or allow at least five minutes for clock skew. </b>Due to clock skew, a SAS token might start or expire earlier or later than expected. If you do not specify a start time, then the start time is considered to be now, and you do not have to worry about clock skew for the start time. </li>
<li><b>Limit the lifetime of SAS tokens and treat it as a Lease. </b>Clients that need more time can request an updated SAS token. </li>
<li><b>Be aware of version: </b>Starting 2012-02-12 version, SAS tokens will contain a new version parameter (sv). sv defines how the various parameters in the SAS token must be interpreted and the version of the REST API to use to execute the operation. This implies that services that are responsible for providing SAS tokens to client applications for the version of the REST protocol that they understand. Make sure clients understand the REST protocol version specified by sv when they are given a SAS to use. </li>
</ol>
<h3>Table SAS</h3>
<p>SAS for table allows account owners to grant SAS token access by defining the following restriction on the SAS policy:</p>
<p>1. <b>Table granularity</b>: users can grant access to an entire table (<i>tn</i>) or to a table range defined by a table (<i>tn</i>) along with a partition key range (<i>startpk</i>/<i>endpk</i>) and row key range (<i>startrk</i>/<i>endrk</i>). </p>
<p>To better understand the range to which access is granted, let us take an example data set:<br/>
<table cellspacing="0" cellpadding="0" border="1">
<tbody>
<tr>
<td valign="top" width="100">
<p>Row Number</p>
</td>
<td valign="top" width="211">
<p>PartitionKey</p>
</td>
<td valign="top" width="199">
<p>RowKey</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>1</p>
</td>
<td valign="top" width="211">
<p>PK001</p>
</td>
<td valign="top" width="199">
<p>RK001</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>2</p>
</td>
<td valign="top" width="211">
<p>PK001</p>
</td>
<td valign="top" width="199">
<p>RK002</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>3</p>
</td>
<td valign="top" width="211">
<p>PK001</p>
</td>
<td valign="top" width="199">
<p>RK003</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>…</p>
</td>
<td valign="top" width="211">
<p>…</p>
</td>
<td valign="top" width="199">
<p>…</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>300</p>
</td>
<td valign="top" width="211">
<p>PK001</p>
</td>
<td valign="top" width="199">
<p>RK300</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>301</p>
</td>
<td valign="top" width="211">
<p>PK002</p>
</td>
<td valign="top" width="199">
<p>RK001</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>302</p>
</td>
<td valign="top" width="211">
<p>PK002</p>
</td>
<td valign="top" width="199">
<p>RK002</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>303</p>
</td>
<td valign="top" width="211">
<p>PK002</p>
</td>
<td valign="top" width="199">
<p>RK003</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>…</p>
</td>
<td valign="top" width="211">
<p>…</p>
</td>
<td valign="top" width="199">
<p>…</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>600</p>
</td>
<td valign="top" width="211">
<p>PK002</p>
</td>
<td valign="top" width="199">
<p>RK300</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>601</p>
</td>
<td valign="top" width="211">
<p>PK003</p>
</td>
<td valign="top" width="199">
<p>RK001</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>602</p>
</td>
<td valign="top" width="211">
<p>PK003</p>
</td>
<td valign="top" width="199">
<p>RK002</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>603</p>
</td>
<td valign="top" width="211">
<p>PK003</p>
</td>
<td valign="top" width="199">
<p>RK003</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>…</p>
</td>
<td valign="top" width="211">
<p>…</p>
</td>
<td valign="top" width="199">
<p>…</p>
</td>
</tr>
<tr>
<td valign="top" width="100">
<p>900</p>
</td>
<td valign="top" width="211">
<p>PK003</p>
</td>
<td valign="top" width="199">
<p>RK300</p>
</td>
</tr>
</tbody>
</table>
<p>The permission is specified as range of rows from (starpk,startrk) until (endpk, endrk).</p>
<p>Example 1: (starpk,startrk) =(,) (endpk, endrk)=(,)    <br/>Allowed Range = All rows in table</p>
<p>Example 2: (starpk,startrk) =(PK002,) (endpk, endrk)=(,)    <br/>Allowed Range = All rows starting from row # 301</p>
<p>Example 3: (starpk,startrk) =(PK002,) (endpk, endrk)=(PK002,)    <br/>Allowed Range = All rows starting from row # 301 and ending at row # 600</p>
<p>Example 3: (starpk,startrk) =(PK001,RK002) (endpk, endrk)=(PK003,RK003)    <br/>Allowed Range = All rows starting from row # 2 and ending at row # 603.     <br/>NOTE: The row (PK002, RK100) is accessible and the row key limit is hierarchical and not absolute (i.e. it is not applied as startrk &lt;= rowkey &lt;= endrk).</p>
<p>2. <b>Access permissions</b> (<i>sp</i>): user can grant access rights to the specified table or table range such as Query (r), Add (a), Update (u), Delete (d) or a combination of them.</p>
<p>3. <b>Time range</b> (<i>st/se</i>): users can limit the SAS token access time. Start time (st) is optional but Expiry time (se) is mandatory, and no limits are enforced on these parameters. Therefore a SAS token may be valid for a very large time period.</p>
<p>4. <b>Server stored access policy </b>(si)<b>: </b>users can either generate offline SAS tokens where the policy permissions described above is part of the SAS token, or they can choose to store specific policy settings associated with a table. These policy settings are limited to the time range (start time and end time) and the access permissions. Stored access policy provides additional control over generated SAS tokens where policy settings could be changed at any time without the need to re-issue a new token. In addition, revoking SAS access would become possible without the need to change the account’s key.</p>
<p>For more information on the different policy settings for Table SAS and the REST interface, please refer to the <a href="http://go.microsoft.com/fwlink/?LinkId=512473" target="_blank">SAS MSDN documentation</a>.</p>
<p>Though non-revocable Table SAS provides large time period access to a resource, we highly recommend that you always limit its validity to a minimum required amount of time in case the SAS token is leaked or the holder of the token is no longer trusted. In that case, the only way to revoke access is to rotate the account’s key that was used to generate the SAS, which would also revoke any other SAS tokens that were already issued and are currently in use. In cases where large time period access is needed, we recommend that you use a server stored access policy as described above. </p>
<p>Most Shared Access Signature usage falls into two different scenarios:</p>
<ol>
<li>A service granting access to clients, so those clients can access their parts of the storage account or access the storage account with restricted permissions. Example: a Windows Phone app for a service running on Windows Azure. A SAS token would be distributed to clients (the Windows Phone app) so it can have direct access to storage. </li>
<li>A service owner who needs to keep his production storage account credentials confined within a limited set of machines or Windows Azure roles which act as a key management system. In this case, a SAS token will be issued on an as-needed basis to worker or web roles that require access to specific storage resources. This allows services to reduce the risk of getting their keys compromised. </li>
</ol>
<p>Along with the different usage scenarios, SAS token generation usually follows the models below:</p>
<ul>
<li>A SAS Token Generator or producer service responsible for issuing SAS tokens to applications, referred to as SAS consumers. The SAS token generated is usually for limited amount of time to control access. This model usually works best with the first scenario described earlier where a phone app (SAS consumer) would request access to a certain resource by contacting a SAS generator service running in the cloud. Before the SAS token expires, the consumer would again contact the service for a renewed SAS. The service can refuse to produce any further tokens to certain applications or users, for example in the scenario where a user’s subscription to the service has expired. Diagram 1 illustrates this model. </li>
</ul>
<p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/36/55/metablogapi/3465.clip_image002_530188B6.jpg" original-url="http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-36-55-metablogapi/3465.clip_5F00_image002_5F00_530188B6.jpg"><img title="clip_image002" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="clip_image002" src="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/01/36/55/metablogapi/8171.clip_image002_thumb_15FD5724.jpg" original-url="http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-36-55-metablogapi/8171.clip_5F00_image002_5F00_thumb_5F00_15FD5724.jpg" width="570" height="484"/></a></p>
<p>Diagram 1: SAS Consumer/Producer Request Flow</p>
<ul>
<li>The communication channel between the application (SAS consumer) and SAS Token Generator could be service specific where the service would authenticate the application/user (for example, using OAuth authentication mechanism) before issuing or renewing the SAS token. We highly recommend that the communication be a secure one in order to avoid any SAS token leak. Note that steps 1 and 2 would only be needed whenever the SAS token approaches its expiry time or the application is requesting access to a different resource. A SAS token can be used as long as it is valid which means multiple requests could be issued (steps 3 and 4) before consulting back with the SAS Token Generator service. </li>
<li>A one-time generated SAS token tied to a signed identifier controlled as part of a <a href="http://msdn.microsoft.com/en-us/library/windowsazure/ee393341">stored access policy</a>. This model would work best in the second scenario described earlier where the SAS token could either be part of a worker role configuration file, or issued once by a SAS token generator/producer service where maximum access time could be provided. In case access needs to be revoked or permission and/or duration changed, the account owner can use the <a href="http://msdn.microsoft.com/en-us/library/windowsazure/jj159102">Set Table ACL</a> API to modify the stored policy associated with issued SAS token. </li>
</ul>
<h4>Table SAS - Sample Scenario Code</h4>
<p>In this section we will provide a usage scenario for Table SAS along with a sample code using the <a href="https://github.com/WindowsAzure/azure-sdk-for-net/tree/sdk_1.7.1">Storage Client Library 1.7.1</a>.</p>
<p>Consider an address book service implementation that needs to scale to a large number of users. The service allows its customers to store their address book in the cloud and access it anywhere using a wide range of clients such as a phone app, desktop app, a website, etc. which we will refer to as the client app. Once a user subscribes to the service, he would be able to add, edit, and query his address book entries. One way to build such system is to run a service in Windows Azure Compute consisting of web and worker roles. The service would act as a middle tier between the client app and the Windows Azure storage system. After the service authenticates it, the client app would be able to access its own address book through a web interface defined by the service. The service would then service all of the client requests by accessing a Windows Azure Table where the address book entries for each of the customer reside. Since the service is involved in processing every request issued by the client, the service would need to scale out its number of Windows Azure Compute instances linearly with the growth of its customer base. </p>
<p>With Table SAS, this scenario becomes simpler to implement. Table SAS can be used to allow the client app to directly access the customer’s address book data that is stored in a Windows Azure Table. This approach would tremendously improve the scalability of the system and reduce cost by removing the service involvement out of the way whenever the client app accesses the address book data. The service role in this case would then be restricted to processing users’ subscription to the service and to generate SAS tokens that are used by the client app to access the stored data directly. Since the token can be granted for any selected time period, the application would need to communicate with the service generating the token only once every selected time period for a given type of access per table. This way, the usage of Table SAS will improve the performance and helps in easily scaling up the system while decreasing the operation cost since fewer servers are needed in this case.</p>
<p>The design of the system using Table SAS would be as follows: A Windows Azure Table called “AddressBook” will be used to store the address book entries for all the customers. The PartitionKey will be the customer’s username or customerID and the RowKey will represent the address book entry key defined as the contact’s <i>LastName,FirstName</i>. This means that all the entries for a certain customer would share the same PartitionKey, the customerID, so the whole address book will be contained within the same PatitionKey for a customer. The following C# class describes the address book entity.</p>
<pre class="code">[DataServiceKey(<span style="color: #a31515">&quot;PartitionKey&quot;</span>, <span style="color: #a31515">&quot;RowKey&quot;</span>)]
<span style="color: blue">public class </span><span style="color: #2b91af">AddressBookEntry
</span>{
    <span style="color: blue">public </span>AddressBookEntry(<span style="color: blue">string </span>partitionKey, <span style="color: blue">string </span>rowKey)
    {
        <span style="color: blue">this</span>.PartitionKey = partitionKey;
        <span style="color: blue">this</span>.RowKey = rowKey;
    }
 
    <span style="color: blue">public </span>AddressBookEntry() { }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Account CustomerID
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public string </span>PartitionKey { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
   /// </span><span style="color: green">Contact Identifier LastName,FirstName
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public string </span>RowKey { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">The last modified time of the entity set by
    </span><span style="color: gray">/// </span><span style="color: green">the Windows Azure Storage
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public </span>DateTime Timestamp { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: blue">public string </span>Address { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: blue">public string </span>Email { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: blue">public string </span>PhoneNumber { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
}</pre>
<p>The address book service consists of the following 2 components:</p>
<ol>
<li><b>A SAS token producer,</b> which is running as part of a service on Windows Azure Compute, accepts requests from the client app asking for a SAS token to give it access to a particular customer’s address book data. This service would first authenticate the client app through its preferred authentication scheme, and then it would generate a SAS token that grants access to the “AddressBook” table while restricting the view to the PartitionKey that is equal to the customerID. Full permission access would be given in order to allow the client app to query (r), update (u), add (a) and delete (d) address book entries. Access time would be restricted to 30 minutes in case the service decides to deny access to certain customers in case, for example his address book subscription expired. In this case, no further renewal for the SAS token would be permitted. The 30 minute period largely reduces the load on SAS token producer compared to a service that acts as a proxy for every request. </li>
<li><b>The client app</b> is responsible for interacting with the customer where it would query, update, insert, and delete address book entries. The client app would first contact the SAS producer service in order to retrieve a SAS token and caches it locally while the token is still valid. The SAS token would be used with any Table REST request against the Windows Azure Storage. The client app would request a new SAS token whenever the current one approaches its expiry time. A standard approach is to renew the SAS every N minutes, where N is half of the time the allocated SAS tokens are valid. For this example, the SAS tokens are valid for 30 minutes, so the client renews the SAS once every 15 minutes. This gives the client time to alert and retry if there is any issue obtaining a SAS renewal. It also helps in cases where application and network latencies cause requests to be delayed in reaching the Windows Azure Storage system. </li>
</ol>
<p>The SAS Producer code can be found below. It is represented by the SasProducer class that implements the RequestSasToken responsible for issuing a SAS token to the client app. In this example, the communication between the client app and the SAS producer is assumed to be a method call for illustration purposes where the client app would simply invoke the RequestSasToken method whenever it requires a new token to be generated.</p>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">The producer class that controls access to the address book
</span><span style="color: gray">/// </span><span style="color: green">by generating sas tokens to clients requesting access to their
</span><span style="color: gray">/// </span><span style="color: green">own address book data
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">public class </span><span style="color: #2b91af">SasProducer
</span>{
    <span style="color: green">/* ... */
 
    </span><span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Issues a SAS token authorizing access to the address book for a given customer ID.
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;customerId&quot;&gt;</span><span style="color: green">The customer ID requesting access.</span><span style="color: gray">&lt;/param&gt;
    /// &lt;returns&gt;</span><span style="color: green">A SAS token authorizing access to the customer's address book entries.</span><span style="color: gray">&lt;/returns&gt;
    </span><span style="color: blue">public string </span>RequestSasToken(<span style="color: blue">string </span>customerId)
    {
        <span style="color: green">// Omitting any authentication code since this is beyond the scope of
        // this sample code
 
        // creating a shared access policy that expires in 30 minutes.
        // No start time is specified, which means that the token is valid immediately.
        // The policy specifies full permissions.
        </span>SharedAccessTablePolicy policy = <span style="color: blue">new </span>SharedAccessTablePolicy()
        {
            SharedAccessExpiryTime = DateTime.UtcNow.AddMinutes(
                <span style="color: #2b91af">SasProducer</span>.AccessPolicyDurationInMinutes),
            Permissions = SharedAccessTablePermissions.Add
                | SharedAccessTablePermissions.Query
                | SharedAccessTablePermissions.Update
                | SharedAccessTablePermissions.Delete
        };
 
        <span style="color: green">// Generate the SAS token. No access policy identifier is used which
        // makes it a non-revocable token
        // limiting the table SAS access to only the request customer's id
        </span><span style="color: blue">string </span>sasToken = <span style="color: blue">this</span>.addressBookTable.GetSharedAccessSignature(
            policy   <span style="color: green">/* access policy */</span>,
            <span style="color: blue">null     </span><span style="color: green">/* access policy identifier */</span>,
            customerId <span style="color: green">/* start partition key */</span>,
            <span style="color: blue">null     </span><span style="color: green">/* start row key */</span>,
            customerId <span style="color: green">/* end partition key */</span>,
            <span style="color: blue">null     </span><span style="color: green">/* end row key */</span>);
 
        <span style="color: blue">return </span>sasToken;
    }
 }</pre>
<p>Note that by not setting the SharedAccessStartTime, Windows Azure Storage would assume that the SAS is valid upon the receipt of the request. </p>
<p>The client app code can be found below. It is represented by the Client class that exposes public methods for manipulating the customer’s address book such UpsertEntry and LookupByName which internally would request from the service front-end, represented by the SasProducer, a SAS token if needed.</p>
<p>&#160;</p>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">The address book client class.
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">public class </span><span style="color: #2b91af">Client
</span>{
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">When to refresh the credentials, measured as a number of minutes before expiration.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private const int </span>SasRefreshThresholdInMinutes = 15;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">the cached copy of the sas credentials of the customer's addressbook
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private </span><span style="color: #2b91af">StorageCredentialsSharedAccessSignature </span>addressBookSasCredentials;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Sas expiration time, used to determine when a refresh is needed
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private </span>DateTime addressBookSasExpiryTime;
 
    <span style="color: green">/* ... */
 
    </span><span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Gets the Table SAS storage credentials accessing the address book
    </span><span style="color: gray">/// </span><span style="color: green">of this particular customer.
    </span><span style="color: gray">/// </span><span style="color: green">The method automatically refreshes the credentials as needed
    </span><span style="color: gray">/// </span><span style="color: green">and caches it locally
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public </span><span style="color: #2b91af">StorageCredentials </span>GetAddressBookSasCredentials()
    {
        <span style="color: green">// Refresh the credentials if needed.
        </span><span style="color: blue">if </span>(<span style="color: blue">this</span>.addressBookSasCredentials == <span style="color: blue">null </span>||
            DateTime.UtcNow.AddMinutes(SasRefreshThresholdInMinutes) &gt;= <span style="color: blue">this</span>.addressBookSasExpiryTime)
        {
            <span style="color: blue">this</span>.RefreshAccessCredentials();
        }
 
        <span style="color: blue">return this</span>.addressBookSasCredentials;
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Requests a new SAS token from the producer, and updates the cached credentials
    </span><span style="color: gray">/// </span><span style="color: green">and the expiration time.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public void </span>RefreshAccessCredentials()
    {
        <span style="color: green">// Request the SAS token.
        </span><span style="color: blue">string </span>sasToken = <span style="color: blue">this</span>.addressBookService.RequestSasToken(<span style="color: blue">this</span>.customerId);
 
        <span style="color: green">// Create credentials using the new token.
        </span><span style="color: blue">this</span>.addressBookSasCredentials = <span style="color: blue">new </span><span style="color: #2b91af">StorageCredentialsSharedAccessSignature</span>(sasToken);
        <span style="color: blue">this</span>.addressBookSasExpiryTime = DateTime.UtcNow.AddMinutes(
            <span style="color: #2b91af">SasProducer</span>.AccessPolicyDurationInMinutes);
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Retrieves the address book entry for the given contact name.
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;contactname&quot;&gt;
    /// </span><span style="color: green">The lastName,FirstName for the requested address book entry.</span><span style="color: gray">&lt;/param&gt;
    /// &lt;returns&gt;</span><span style="color: green">An address book entry with a certain contact card</span><span style="color: gray">&lt;/returns&gt;
    </span><span style="color: blue">public </span>AddressBookEntry LookupByName(<span style="color: blue">string </span>contactname)
    {
        <span style="color: #2b91af">StorageCredentials </span>credentials = GetAddressBookSasCredentials();
        <span style="color: #2b91af">CloudTableClient </span>tableClient = <span style="color: blue">new </span><span style="color: #2b91af">CloudTableClient</span>(<span style="color: blue">this</span>.tableEndpoint, credentials);
 
        <span style="color: #2b91af">TableServiceContext </span>context = tableClient.GetDataServiceContext();
 
        <span style="color: #2b91af">CloudTableQuery</span>&lt;AddressBookEntry&gt; query = 
            (<span style="color: blue">from </span>entry <span style="color: blue">in </span>context.CreateQuery&lt;AddressBookEntry&gt;(<span style="color: #2b91af">Client</span>.AddressBookTableName)
             <span style="color: blue">where </span>entry.PartitionKey == <span style="color: blue">this</span>.customerId &amp;&amp; entry.RowKey == contactname
             <span style="color: blue">select </span>entry).AsTableServiceQuery();
 
        <span style="color: blue">return </span>query.Execute().SingleOrDefault();
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Inserts a new address book entry or updates an existing entry.
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;entry&quot;&gt;</span><span style="color: green">The address book entry to insert or merge.</span><span style="color: gray">&lt;/param&gt;
    </span><span style="color: blue">public void </span>UpsertEntry(AddressBookEntry entry)
    {
        <span style="color: #2b91af">StorageCredentials </span>credentials = GetAddressBookSasCredentials();
        <span style="color: #2b91af">CloudTableClient </span>tableClient = <span style="color: blue">new </span><span style="color: #2b91af">CloudTableClient</span>(<span style="color: blue">this</span>.tableEndpoint, credentials);
 
        <span style="color: #2b91af">TableServiceContext </span>context = tableClient.GetDataServiceContext();
 
        <span style="color: green">// Set the correct customer ID.
        </span>entry.PartitionKey = <span style="color: blue">this</span>.customerId;
 
        <span style="color: green">// Upsert the entry (Insert or Merge).
        </span>context.AttachTo(<span style="color: #2b91af">Client</span>.AddressBookTableName, entry);
        context.UpdateObject(entry);
        context.SaveChangesWithRetries();
    }
}</pre>
<h3>Stored Access Policy Sample Code</h3>
<p>As an extension to the previous example, consider that the address book service is implementing a garbage collector (GC) that would delete the address book data for users that are no longer consumers of the service. In this case, and in order to avoid the chance of having the storage account credentials be compromised, the GC worker role would use a Table SAS token with maximum access time that is backed by a stored access policy associated with a signed identifier. The Table SAS token would grant access to the “AddressBook” table without specifying any range restrictions on the PartitionKey and RowKey but with delete-only permission. In case the SAS token gets leaked, the service owner would be able to revoke the SAS access by deleting the signed identifier associated with the “AddressBook” table as will be highlighted later through code. To be sure that the SAS access does not get inadvertently reinstated after revocation, the policy identifier has as part of its name the policy’s date and time of creation. (See the section on Best Practices When Using SAS below.)</p>
<p>In addition, assume that the GC worker role would come to be aware of the customerID that it needs to GC is through a Queue called “gcqueue”. Whenever a customer subscription expires, a message is enqueued into the “gcqueue” queue. The GC worker role would keep polling that queue at a regular interval. Once a customerID is dequeued, the worker role would delete that customer’s data and on completion, deletes the queue message associated with that customer. For the same reasons a SAS token is used to access the “AddressBook” table, the GC worker thread would also use a Queue SAS token associated with the “gcqueue” queue while using a stored access policy as well. The permissions needed in this case would be Process-only. More details on Queue SAS are available in the subsequent sections of this post.</p>
<p>To build this additional GC feature, the SAS token producer will be extended to generate a one-time Table SAS token against the “AddressBook” table and a one-time Queue SAS token against the “gcqueue” Queue by associating them with stored access signed identifiers with their respective table and queue as explained earlier. The GC role upon initialization, would contact the SAS token producer in order to retrieve these two SAS tokens.</p>
<p>The additional code needed as part of the SAS producer is as follow.</p>
<pre class="code"><span style="color: blue">public const string </span>GCQueueName = <span style="color: #a31515">&quot;gcqueue&quot;</span>;

<span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">The garbage collection queue.
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">private </span>CloudQueue gcQueue;

<span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">Generates an address book table and a GC queue 
</span><span style="color: gray">/// </span><span style="color: green">revocable SAS tokens that is used by the GC worker role
</span><span style="color: gray">/// &lt;/summary&gt;
/// &lt;param name=&quot;tableSasToken&quot;&gt;
/// </span><span style="color: green">An out parameter which returns a revocable SAS token to 
</span><span style="color: gray">/// </span><span style="color: green">access the AddressBook table with delele only permissions</span><span style="color: gray">&lt;/param&gt;
/// &lt;param name=&quot;queueSasToken&quot;&gt;
/// </span><span style="color: green">An out parameter which returns a revocable SAS token to 
</span><span style="color: gray">/// </span><span style="color: green">access the gcqueue with process permissions</span><span style="color: gray">&lt;/param&gt;
</span><span style="color: blue">public void </span>GetGCSasTokens(<span style="color: blue">out string </span>tableSasToken, <span style="color: blue">out string </span>queueSasToken)
{
    <span style="color: blue">string </span>gcPolicySignedIdentifier = <span style="color: #a31515">&quot;GCAccessPolicy&quot; </span>+ DateTime.UtcNow.ToString();
 
    <span style="color: green">// Create the GC worker's address book SAS policy 
    // that will be associated with a signed identifer
    </span>TablePermissions addressBookPermissions = <span style="color: blue">new </span>TablePermissions();
    SharedAccessTablePolicy gcTablePolicy = <span style="color: blue">new </span>SharedAccessTablePolicy()
    {
        <span style="color: green">// Providing the max duration
        </span>SharedAccessExpiryTime = DateTime.MaxValue,
        <span style="color: green">// Permission is granted to query and delete entries.
        </span>Permissions = SharedAccessTablePermissions.Query | SharedAccessTablePermissions.Delete
    };
 
    <span style="color: green">// Associate the above policy with a signed identifier
    </span>addressBookPermissions.SharedAccessPolicies.Add(
        gcPolicySignedIdentifier,
        gcTablePolicy);
 
    <span style="color: green">// The below call will result in a Set Table ACL request to be sent to 
    // Windows Azure Storage in order to store the policy and associate it with the 
    // &quot;GCAccessPolicy&quot; signed identifier that will be referred to
    // by the generated SAS token
    </span><span style="color: blue">this</span>.addressBookTable.SetPermissions(addressBookPermissions);
 
    <span style="color: green">// Create the SAS tokens using the above policies.
    // There are no restrictions on partition key and row key.
    // It also uses the signed identifier as part of the token.
    // No requests will be sent to Windows Azure Storage when the below call is made.
    </span>tableSasToken = <span style="color: blue">this</span>.addressBookTable.GetSharedAccessSignature(
        <span style="color: blue">new </span>SharedAccessTablePolicy(),
        gcPolicySignedIdentifier,
        <span style="color: blue">null </span><span style="color: green">/* start partition key */</span>,
        <span style="color: blue">null </span><span style="color: green">/* start row key */</span>,
        <span style="color: blue">null </span><span style="color: green">/* end partition key */</span>,
        <span style="color: blue">null </span><span style="color: green">/* end row key */</span>);
 
    <span style="color: green">// Initializing the garbage collection queue and creating a Queue SAS token
    // by following similar steps as the table SAS
    </span>CloudQueueClient queueClient = 
        <span style="color: blue">this</span>.serviceStorageAccount.CreateCloudQueueClient();
    <span style="color: blue">this</span>.gcQueue = queueClient.GetQueueReference(GCQueueName);
    <span style="color: blue">this</span>.gcQueue.CreateIfNotExist();
 
    <span style="color: green">// Create the GC queue SAS policy.
    </span>QueuePermissions gcQueuePermissions = <span style="color: blue">new </span>QueuePermissions();
    SharedAccessQueuePolicy gcQueuePolicy = <span style="color: blue">new </span>SharedAccessQueuePolicy()
    {
        <span style="color: green">// Providing the max duration
        </span>SharedAccessExpiryTime = DateTime.MaxValue,
        <span style="color: green">// Permission is granted to process queue messages.
        </span>Permissions = SharedAccessQueuePermissions.ProcessMessages
    };
 
    <span style="color: green">// Associate the above policy with a signed identifier
    </span>gcQueuePermissions.SharedAccessPolicies.Add(
        gcPolicySignedIdentifier,
        gcQueuePolicy);
 
    <span style="color: green">// The below call will result in a Set Queue ACL request to be sent to 
    // Windows Azure Storage in order to store the policy and associate it with the 
    // &quot;GCAccessPolicy&quot; signed identifier that will be referred to
    // by the generated SAS token
    </span><span style="color: blue">this</span>.gcQueue.SetPermissions(gcQueuePermissions);
 
    <span style="color: green">// Create the SAS tokens using the above policy which 
    // uses the signed identifier as part of the token.
    // No requests will be sent to Windows Azure Storage when the below call is made.
    </span>queueSasToken = <span style="color: blue">this</span>.gcQueue.GetSharedAccessSignature(
        <span style="color: blue">new </span>SharedAccessQueuePolicy(),
        gcPolicySignedIdentifier);
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>Whenever customer’s data needs to be deleted the following method will be called which is assumed to be part of the SasProducer class for simplicity. </p>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">Flags the given customer ID for garbage collection.
</span><span style="color: gray">/// &lt;/summary&gt;
/// &lt;param name=&quot;customerId&quot;&gt;</span><span style="color: green">The customer ID to delete.</span><span style="color: gray">&lt;/param&gt;
</span><span style="color: blue">public void </span>DeleteCustomer(<span style="color: blue">string </span>customerId)
{
    <span style="color: green">// Add the customer ID to the GC queue.
    </span>CloudQueueMessage message = <span style="color: blue">new </span>CloudQueueMessage(customerId);
    <span style="color: blue">this</span>.gcQueue.AddMessage(message);
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>In case a SAS token needs to be revoked, the following method would need to be invoked. Once the below method is called, any malicious user who might have gained access to these SAS tokens will be denied access. The garbage collector could in this case request new token from the SAS Producer.</p>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">Revokes Revocable SAS access to a Table that is associated
</span><span style="color: gray">/// </span><span style="color: green">with a policy referred to by the signedIdentifier
</span><span style="color: gray">/// &lt;/summary&gt;
/// &lt;param name=&quot;table&quot;&gt;
/// </span><span style="color: green">Reference to the CloudTable in question. 
</span><span style="color: gray">/// </span><span style="color: green">The table must be created with a signed key access, 
</span><span style="color: gray">/// </span><span style="color: green">since otherwise Set/Get Table ACL would fail</span><span style="color: gray">&lt;/param&gt;
/// &lt;param name=&quot;signedIdentifier&quot;&gt;</span><span style="color: green">the SAS signedIdentifier to revoke</span><span style="color: gray">&lt;/param&gt;
</span><span style="color: blue">public void </span>RevokeAccessToTable(CloudTable table, <span style="color: blue">string </span>signedIdentifier)
{
    <span style="color: green">// Retrieve the current policies and SAS signedIdentifier 
    // associated with the table by invoking Get Table ACL
    </span>TablePermissions tablePermissions = table.GetPermissions();
    
    <span style="color: green">// Attempt to remove the signedIdentifier to revoke from the list
    </span><span style="color: blue">bool </span>success = tablePermissions.SharedAccessPolicies.Remove(signedIdentifier);
 
    <span style="color: blue">if </span>(success)
    {
        <span style="color: green">// Commit the changes by invoking Set Table ACL 
        // without the signedidentifier that needs revoking
        </span><span style="color: blue">this</span>.addressBookTable.SetPermissions(tablePermissions);
    }
    <span style="color: green">// else the signedIdentifier does not exist, therefore no need to 
    // call Set Table ACL
</span>}</pre>
<p>The garbage collection code that uses the generated SAS tokens is as follow.</p>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">The garbage collection worker class.
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">public class </span><span style="color: #2b91af">GCWorker
</span>{
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">The address book table.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private </span>CloudTable addressBook;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">The garbage collection queue.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private </span><span style="color: #2b91af">CloudQueue </span>gcQueue;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Initializes a new instance of the GCWorker class
    </span><span style="color: gray">/// </span><span style="color: green">by passing in the required SAS credentials to access the 
    </span><span style="color: gray">/// </span><span style="color: green">AddressBook Table and the gcqueue Queue
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public </span>GCWorker(
        <span style="color: blue">string </span>tableEndpoint,
        <span style="color: blue">string </span>sasTokenForAddressBook,
        <span style="color: blue">string </span>queueEndpoint,
        <span style="color: blue">string </span>sasTokenForQueue)
    {
        <span style="color: #2b91af">StorageCredentials </span>credentialsForAddressBook = 
            <span style="color: blue">new </span><span style="color: #2b91af">StorageCredentialsSharedAccessSignature</span>(sasTokenForAddressBook);
        <span style="color: #2b91af">CloudTableClient </span>tableClient = 
            <span style="color: blue">new </span><span style="color: #2b91af">CloudTableClient</span>(tableEndpoint, credentialsForAddressBook);
        <span style="color: blue">this</span>.addressBook = 
            tableClient.GetTableReference(<span style="color: #2b91af">SasProducer</span>.AddressBookTableName);
 
        <span style="color: #2b91af">StorageCredentials </span>credentialsForQueue = 
            <span style="color: blue">new </span><span style="color: #2b91af">StorageCredentialsSharedAccessSignature</span>(sasTokenForQueue);
        <span style="color: #2b91af">CloudQueueClient </span>queueClient = 
            <span style="color: blue">new </span><span style="color: #2b91af">CloudQueueClient</span>(queueEndpoint, credentialsForQueue);
        <span style="color: blue">this</span>.gcQueue = 
            queueClient.GetQueueReference(<span style="color: #2b91af">SasProducer</span>.GCQueueName);
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Starts the GC worker, which polls the GC queue for messages 
    </span><span style="color: gray">/// </span><span style="color: green">containing customerID to be garbage collected.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public void </span>Start()
    {
        <span style="color: blue">while </span>(<span style="color: blue">true</span>)
        {
            <span style="color: green">// Get a message from the queue by settings its visibility time to 2 minutes
            </span><span style="color: #2b91af">CloudQueueMessage </span>message = <span style="color: blue">this</span>.gcQueue.GetMessage(TimeSpan.FromMinutes(2));
 
            <span style="color: green">// If there are no messages, sleep and retry.
            </span><span style="color: blue">if </span>(message == <span style="color: blue">null</span>)
            {
                Thread.Sleep(TimeSpan.FromMinutes(1));
                <span style="color: blue">continue</span>;
            }
 
            <span style="color: green">// The account name is the message body.
            </span><span style="color: blue">string </span>customerIDToGC = message.AsString;
 
            <span style="color: green">// Create a context for querying and modifying the address book.
            </span><span style="color: #2b91af">TableServiceContext </span>context = <span style="color: blue">this</span>.addressBook.ServiceClient.GetDataServiceContext();
 
            <span style="color: green">// Find all entries in a given account.
            </span><span style="color: #2b91af">CloudTableQuery</span>&lt;AddressBookEntry&gt; query = 
                (<span style="color: blue">from </span>entry <span style="color: blue">in </span>context.CreateQuery&lt;AddressBookEntry&gt;(<span style="color: blue">this</span>.addressBook.Name)
                 <span style="color: blue">where </span>entry.PartitionKey == customerIDToGC
                 <span style="color: blue">select </span>entry).AsTableServiceQuery();
 
            <span style="color: blue">int </span>numberOfEntriesInBatch = 0;
 
            <span style="color: green">// Delete entries in batches since all of the contact entries share 
            // the same partitionKey
            </span><span style="color: blue">foreach </span>(AddressBookEntry r <span style="color: blue">in </span>query.Execute())
            {
                context.DeleteObject(r);
                numberOfEntriesInBatch++;
 
                <span style="color: blue">if </span>(numberOfEntriesInBatch == 100)
                {
                    <span style="color: green">// Commit the batch of 100 deletions to the service.
                    </span>context.SaveChangesWithRetries(SaveChangesOptions.Batch);
                    numberOfEntriesInBatch = 0;
                }
            }
 
            <span style="color: blue">if </span>(numberOfEntriesInBatch &gt; 0)
            {
                <span style="color: green">// Commit the remaining deletions (if any) to the service.
                </span>context.SaveChangesWithRetries(SaveChangesOptions.Batch);
            }
 
            <span style="color: green">// Delete the message from the queue.
            </span><span style="color: blue">this</span>.gcQueue.DeleteMessage(message);
        }
    }
}</pre>
<p>For completion, we are providing the following Main method code to illustrate the above classes and allow you to test the sample code.</p>
<pre class="code"><span style="color: blue">public static void </span>Main()
{
    <span style="color: blue">string </span>accountName = <span style="color: #a31515">&quot;someaccountname&quot;</span>;
    <span style="color: blue">string </span>accountKey = <span style="color: #a31515">&quot;someaccountkey&quot;</span>;
    
    <span style="color: blue">string </span>tableEndpoint = <span style="color: blue">string</span>.Format(
        <span style="color: #a31515">&quot;http://{0}.table.core.windows.net&quot;</span>, accountName);
    <span style="color: blue">string </span>queueEndpoint = <span style="color: blue">string</span>.Format(
        <span style="color: #a31515">&quot;http://{0}.queue.core.windows.net&quot;</span>, accountName);
 
    CloudStorageAccount storageAccount = CloudStorageAccount.Parse(
        <span style="color: blue">string</span>.Format(
            <span style="color: #a31515">&quot;DefaultEndpointsProtocol=http;AccountName={0};AccountKey={1}&quot;</span>,
             accountName, accountKey));

    SasProducer sasProducer = <span style="color: blue">new </span>SasProducer(storageAccount);
    
    <span style="color: blue">string </span>sasTokenForAddressBook, sasTokenForQueue;
    <span style="color: green">// Get the revocable GC SAS tokens
    </span>sasProducer.GetGCSasTokens(<span style="color: blue">out </span>sasTokenForAddressBook, <span style="color: blue">out </span>sasTokenForQueue);
    
    <span style="color: green">// Initialize and start the GC Worker
    </span>GCWorker gcWorker = <span style="color: blue">new </span>GCWorker(
        tableEndpoint,
        sasTokenForAddressBook,
        queueEndpoint,
        sasTokenForQueue);
    ThreadPool.QueueUserWorkItem((state) =&gt; gcWorker.Start());
 
    <span style="color: blue">string </span>customerId = <span style="color: #a31515">&quot;davidhamilton&quot;</span>;
 
    <span style="color: green">// Create a client object
    </span>Client client = <span style="color: blue">new </span>Client(sasProducer, tableEndpoint, customerId);
 
    <span style="color: green">// Add some address book entries
    </span>AddressBookEntry contactEntry = <span style="color: blue">new </span>AddressBookEntry
    {
        RowKey = <span style="color: #a31515">&quot;Harp,Walter&quot;</span>,
        Address = <span style="color: #a31515">&quot;1345 Fictitious St, St Buffalo, NY 98052&quot;</span>,
        PhoneNumber = <span style="color: #a31515">&quot;425-555-0101&quot;
    </span>};
 
    client.UpsertEntry(contactEntry);
 
    contactEntry = <span style="color: blue">new </span>AddressBookEntry
    {
        RowKey = <span style="color: #a31515">&quot;Foster,Jonathan&quot;</span>,
        Email = <span style="color: #a31515">&quot;Jonathan@fourthcoffee.com&quot;
    </span>};
 
    client.UpsertEntry(contactEntry);
 
    contactEntry = <span style="color: blue">new </span>AddressBookEntry
    {
        RowKey = <span style="color: #a31515">&quot;Miller,Lisa&quot;</span>,
        PhoneNumber = <span style="color: #a31515">&quot;425-555-2141&quot;
    </span>};
 
    client.UpsertEntry(contactEntry);
 
    <span style="color: green">// Update Walter's Contact entry with an email address
    </span>contactEntry = <span style="color: blue">new </span>AddressBookEntry
    {
        RowKey = <span style="color: #a31515">&quot;Harp,Walter&quot;</span>,
        Email = <span style="color: #a31515">&quot;Walter@contoso.com&quot;
    </span>};
 
    client.UpsertEntry(contactEntry);
 
    <span style="color: green">// Look up an entry
    </span>contactEntry = client.LookupByName(<span style="color: #a31515">&quot;Foster,Jonathan&quot;</span>);
 
    <span style="color: green">// Delete the customer
    </span>sasProducer.DeleteCustomer(customerId);
 
    <span style="color: green">// Wait for GC
    </span>Thread.Sleep(TimeSpan.FromSeconds(120));
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>&#160;</p>
<h3>Queue SAS</h3>
<p>SAS for queue allows account owners to grant SAS access to a queue by defining the following restriction on the SAS policy:</p>
<ol>
<li><b>Access permissions</b> (<i>sp</i>): users can grant access rights to the specified queue such as Read or Peek at messages (r), Add message (a), Update message (u), and Process message (p) which allows the <a href="http://msdn.microsoft.com/en-us/library/windowsazure/dd179474">Get Messages</a> and <a href="http://msdn.microsoft.com/en-us/library/windowsazure/dd179347">Delete Message</a> REST APIs to be invoked, or a combination of permissions. Note that Process message (p) permissions potentially allow a client to get and delete every message in the queue. Therefore the clients receiving these permissions must be sufficiently trusted for the queue being accessed. </li>
<li><b>Time range</b> (<i>st/se</i>): users can limit the SAS token access time. You can also choose to provide access for maximum duration. </li>
<li><b>Server stored access policy </b>(si)<b>: </b>users can either generate offline SAS tokens where the policy permissions described above is part of the SAS token, or they can choose to store specific policy settings associated with a table. These policy settings are limited to the time range (start time and end time) and the access permissions. Stored access policies provide additional control over generated SAS tokens where policy settings could be changed at any time without the need to re-issue a new token. In addition, revoking SAS access would become possible without the need to change the account’s key. </li>
</ol>
<p>For more information on the different policy settings for Queue SAS and the REST interface, please refer to the <a href="http://go.microsoft.com/fwlink/?LinkId=512473" target="_blank">SAS MSDN documentation</a>.</p>
<p>A typical scenario where Queue SAS can be used is for a notification system where the notification producer would need add-only access to the queue and the consumer needs processing and read access to the queue.</p>
<p>As an example, consider a video processing service that works on videos provided by its customers. The source videos are stored as part of the customer’s Windows Azure Storage account. Once the video is processed by the processing service, the resultant video is stored back as part of the customer’s account. The service provides transcoding to different video quality such as 240p, 480p and 720p. Whenever there are new videos to be processed, the customer client app would send a request to the service which includes the source video blob, the destination video blob and the requested video transcoding quality. The service would then transcode the source video and stores the resultant video back to the customer account location denoted by the destination blob. To design such service without Queue SAS, the system design would include 3 different components: </p>
<ul>
<li><b>Client</b>, creates a SAS token access to the source video blob with read permissions and a destination blob SAS token access with write permissions. The client then sends a request to the processing service front-end along with the needed video transcoding quality. </li>
<li><b>Video processing service front-end</b>, accepts requests by first authenticating the sender using its own preferred authentication scheme. Once authenticated, the front-end enqueues a work item into a Windows Azure Queue called “videoprocessingqueue” that gets processed by a number of video processor worker role instances. </li>
<li><b>Video processor worker role</b>: the worker role would dequeue work items from the “videoprocessingqueue” and processes the request by transcoding the video. The worker role could also extend the visibility time of the work item if more processing time is needed. </li>
</ul>
<p>The above system design would require that the number of front-ends to scale up with the increased number of requests and customer count in order to be able to keep up with the service demand. In addition, client applications are not isolated from unavailability of video processing service front-ends. Having the client application directly interface with the scalable, highly available and durable Queue using SAS would greatly alleviate this requirement and would help make the service run more efficiently and with less computational resources. It also decouples the client applications from availability of video processing service front-ends. In this case, the front-end role could instead issue SAS tokens granting access to the “viodeprocessingqueue” with add message permission for, say, 2 hours. The client can then use the SAS token in order to enqueue requests. When using Queue SAS, the load on the front-end greatly decreases, since the enqueue requests go directly from the client to storage, instead of through the front-end service. The system design would then look like:</p>
<ul>
<li><b>Client</b>, which creates a SAS token access to the source video blob with read permissions and a destination blob SAS token access with write permissions. The client would then contact the front-end and retrieves a SAS token for the “videoprocessingqueue” queue and then enqueues a video processing work item. The client would cache the SAS token for 2 hours and renew it well before it expires. </li>
<li><b>Video processing service front-end</b>, which accepts requests by first authenticating the sender. Once authenticated, it would issue SAS tokens to the “videoprocessingqueue” queue with add message permission and duration limited to 2 hours. </li>
<li><b>Video processor worker role</b>: The responsibility of this worker role would remain unchanged from the previous design. </li>
</ul>
<p>We will now highlight the usage of Queue SAS through code for the video processing service. Authentication and actual video transcoding code will be omitted for simplicity reasons. </p>
<pre>We will first define the video processing work item referred to as TranscodingWorkItem as follow.</pre>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">Enum representing the target video quality requested by the client
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">public enum </span><span style="color: #2b91af">VideoQuality
</span>{
    quality240p,
    quality480p,
    quality720p
}

<span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">class representing the queue message Enqueued by the client
</span><span style="color: gray">/// </span><span style="color: green">and processed by the video processing worker role
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">public class </span><span style="color: #2b91af">TranscodingWorkItem
</span>{
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Blob URL for the source Video that needs to be transcoded
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public string </span>SourceVideoUri { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Blob URl for the resultant video that would be produced
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public string </span>DestinationVideoUri { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">SAS token for the source video with read-only access
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public string </span>SourceSasToken { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">SAS token for destination video with write-only access
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public string </span>DestinationSasToken { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">The requested video quality
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public </span><span style="color: #2b91af">VideoQuality </span>TargetVideoQuality { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Converts the xml representation of the queue message into a TranscodingWorkItem object
    </span><span style="color: gray">/// </span><span style="color: green">This API is used by the Video Processing Worker role
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;messageContents&quot;&gt;</span><span style="color: green">XML snippet representing the TranscodingWorkItem</span><span style="color: gray">&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    </span><span style="color: blue">public static </span><span style="color: #2b91af">TranscodingWorkItem </span>FromMessage(<span style="color: blue">string </span>messageContents)
    {
        XmlSerializer mySerializer = <span style="color: blue">new </span>XmlSerializer(<span style="color: blue">typeof</span>(<span style="color: #2b91af">TranscodingWorkItem</span>));
        <span style="color: #2b91af">StringReader </span>reader = <span style="color: blue">new </span><span style="color: #2b91af">StringReader</span>(messageContents);
        <span style="color: blue">return </span>(<span style="color: #2b91af">TranscodingWorkItem</span>)mySerializer.Deserialize(reader);
    }
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Serializes this TranscodingWorkItem object to an xml string that would be 
    </span><span style="color: gray">/// </span><span style="color: green">used a queue message.
    </span><span style="color: gray">/// </span><span style="color: green">This API is used by the client
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    </span><span style="color: blue">public string </span>ToMessage()
    {
        XmlSerializer mySerializer = <span style="color: blue">new </span>XmlSerializer(<span style="color: blue">typeof</span>(<span style="color: #2b91af">TranscodingWorkItem</span>));
        <span style="color: #2b91af">StringWriter </span>writer = <span style="color: blue">new </span><span style="color: #2b91af">StringWriter</span>();
        mySerializer.Serialize(writer, <span style="color: blue">this</span>);
        writer.Close();
 
        <span style="color: blue">return </span>writer.ToString();
    }
}</pre>
<p>Below, we will highlight the code needed by the front-end part of the service. It will be acting as a SAS generator. This component will generate 2 types of SAS tokens; a non-revocable one that is limited to 2 hours consumed by clients and a one-time, maximum duration, revocable one that is used by the video processing worker role. </p>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">SAS Generator component that is running as part of the service front-end
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">public class </span><span style="color: #2b91af">SasProducer
</span>{
    <span style="color: green">/* ... */

    </span><span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">API invoked by Clients in order to get a SAS token 
    </span><span style="color: gray">/// </span><span style="color: green">that allows them to add messages to the queue.
    </span><span style="color: gray">/// </span><span style="color: green">The token will have add-message permission with a 2 hour limit.
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;returns&gt;</span><span style="color: green">A SAS token authorizing access to the video processing queue.</span><span style="color: gray">&lt;/returns&gt;
    </span><span style="color: blue">public string </span>GetClientSasToken()
    {
        <span style="color: green">// The shared access policy should expire in two hours.
        // No start time is specified, which means that the token is valid immediately.
        // The policy specifies add-message permissions.
        </span>SharedAccessQueuePolicy policy = <span style="color: blue">new </span>SharedAccessQueuePolicy()
        {
            SharedAccessExpiryTime = DateTime.UtcNow.Add(<span style="color: #2b91af">SasProducer</span>.SasTokenDuration),
            Permissions = SharedAccessQueuePermissions.Add
        };
 
        <span style="color: green">// Generate the SAS token. No access policy identifier is used 
        // which makes it non revocable.
        // the token is generated by the client without issuing any calls
        // against the Windows Azure Storage.
        </span><span style="color: blue">string </span>sasToken = <span style="color: blue">this</span>.videoProcessingQueue.GetSharedAccessSignature(
            policy   <span style="color: green">/* access policy */</span>,
            <span style="color: blue">null     </span><span style="color: green">/* access policy identifier */</span>);
 
        <span style="color: blue">return </span>sasToken;
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">This method will generate a revocable SAS token that will be used by 
    </span><span style="color: gray">/// </span><span style="color: green">the video processing worker roles. The role will have process and update
    </span><span style="color: gray">/// </span><span style="color: green">message permissions.
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    </span><span style="color: blue">public string </span>GetSasTokenForProcessingMessages()
    {
        <span style="color: green">// A signed identifier is needed to associate a SAS with a server stored policy
        </span><span style="color: blue">string </span>workerPolicySignedIdentifier = 
            <span style="color: #a31515">&quot;VideoProcessingWorkerAccessPolicy&quot; </span>+ DateTime.UtcNow.ToString();
 
        <span style="color: green">// Create the video processing worker's queue SAS policy.
        // Permission is granted to process and update queue messages.            
        </span>QueuePermissions workerQueuePermissions = <span style="color: blue">new </span>QueuePermissions();
        SharedAccessQueuePolicy workerQueuePolicy = <span style="color: blue">new </span>SharedAccessQueuePolicy()
        {    
            <span style="color: green">// Making the duration max
            </span>SharedAccessExpiryTime = DateTime.MaxValue,
            Permissions = SharedAccessQueuePermissions.ProcessMessages | SharedAccessQueuePermissions.Update
        };
 
        <span style="color: green">// Associate the above policy with a signed identifier
        </span>workerQueuePermissions.SharedAccessPolicies.Add(
            workerPolicySignedIdentifier,
            workerQueuePolicy);
 
        <span style="color: green">// The below call will result in a Set Queue ACL request to be sent to 
        // Windows Azure Storage in order to store the policy and associate it with the 
        // &quot;VideoProcessingWorkerAccessPolicy&quot; signed identifier that will be referred to
        // by the SAS token
        </span><span style="color: blue">this</span>.videoProcessingQueue.SetPermissions(workerQueuePermissions);
 
        <span style="color: green">// Use the signed identifier in order to generate a SAS token. No requests will be
        // sent to Windows Azure Storage when the below call is made.
        </span><span style="color: blue">string </span>revocableSasTokenQueue = <span style="color: blue">this</span>.videoProcessingQueue.GetSharedAccessSignature(
            <span style="color: blue">new </span>SharedAccessQueuePolicy(),
            workerPolicySignedIdentifier);
 
        <span style="color: blue">return </span>revocableSasTokenQueue;
    }
}</pre>
<p>We will now look at the client library code that is running as part of the customer’s application. We will assume that the communication between the client and service front-end is a simple method call invoked on the SasProducer object. In reality, this could be an HTTPS web request that is processed by the front-end and the SAS token is returned as part of the HTTPS response. The client library will use the customer’s storage credentials in order to create SAS to the source and destination video blobs. It would also retrieve the processing video Queue SAS token from the service and enqueues a transcoding work item into it.</p>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">A class representing the client using the video processing service.
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">public class </span><span style="color: #2b91af">Client
</span>{
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">When to refresh the credentials, measured as a number of minutes before expiration.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private const int </span>CredsRefreshThresholdInMinutes = 60;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">The handle to the video processing service, for requesting sas tokens
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private </span><span style="color: #2b91af">SasProducer </span>videoProcessingService;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">a cached copy of the SAS credentials.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private </span><span style="color: #2b91af">StorageCredentialsSharedAccessSignature </span>serviceQueueSasCredentials;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Expiration time for the service SAS token.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private </span>DateTime serviceQueueSasExpiryTime;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">the video processing service storage queue endpoint that is used to
    </span><span style="color: gray">/// </span><span style="color: green">enqueue workitems to
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private string </span>serviceQueueEndpoint;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Initializes a new instance of the Client class.
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;service&quot;&gt;
    /// </span><span style="color: green">A handle to the video processing service object.</span><span style="color: gray">&lt;/param&gt;
    /// &lt;param name=&quot;serviceQueueEndpoint&quot;&gt;
    /// </span><span style="color: green">The video processing service storage queue endpoint that is used to
    </span><span style="color: gray">/// </span><span style="color: green">enqueue workitems to</span><span style="color: gray">&lt;/param&gt;
    </span><span style="color: blue">public </span>Client(<span style="color: #2b91af">SasProducer </span>service, <span style="color: blue">string </span>serviceQueueEndpoint)
    {
        <span style="color: blue">this</span>.videoProcessingService = service;
        <span style="color: blue">this</span>.serviceQueueEndpoint = serviceQueueEndpoint;
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Called by the application in order to request a video to
    </span><span style="color: gray">/// </span><span style="color: green">be transcoded.
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;clientStorageAccountName&quot;&gt;
    /// </span><span style="color: green">The customer's storage account name; Not to be confused
    </span><span style="color: gray">/// </span><span style="color: green">with the service account info</span><span style="color: gray">&lt;/param&gt;
    /// &lt;param name=&quot;clientStorageKey&quot;&gt;</span><span style="color: green">the customer's storage account key.
    </span><span style="color: gray">/// </span><span style="color: green">It is used to generate the SAS access to the customer's videos</span><span style="color: gray">&lt;/param&gt;
    /// &lt;param name=&quot;sourceVideoBlobUri&quot;&gt;</span><span style="color: green">The raw source blob uri</span><span style="color: gray">&lt;/param&gt;
    /// &lt;param name=&quot;destinationVideoBlobUri&quot;&gt;</span><span style="color: green">The raw destination blob uri</span><span style="color: gray">&lt;/param&gt;
    /// &lt;param name=&quot;videoQuality&quot;&gt;</span><span style="color: green">the video quality requested</span><span style="color: gray">&lt;/param&gt;
    </span><span style="color: blue">public void </span>SubmitTranscodeVideoRequest(
        <span style="color: blue">string </span>clientStorageAccountName,
        <span style="color: blue">string </span>clientStorageKey,
        <span style="color: blue">string </span>sourceVideoBlobUri,
        <span style="color: blue">string </span>destinationVideoBlobUri,
        VideoQuality videoQuality)
    {
        <span style="color: green">// Create a reference to the customer's storage account
        // that will be used to generate SAS tokens to the source and destination
        // videos
        </span><span style="color: #2b91af">CloudStorageAccount </span>clientStorageAccount = <span style="color: #2b91af">CloudStorageAccount</span>.Parse(
            <span style="color: blue">string</span>.Format(<span style="color: #a31515">&quot;DefaultEndpointsProtocol=http;AccountName={0};AccountKey={1}&quot;</span>, 
            clientStorageAccountName, clientStorageKey));
 
        <span style="color: #2b91af">CloudBlobClient </span>blobClient = clientStorageAccount.CreateCloudBlobClient();
 
        <span style="color: #2b91af">CloudBlob </span>sourceVideo = <span style="color: blue">new </span><span style="color: #2b91af">CloudBlob</span>(
            sourceVideoBlobUri <span style="color: green">/*blobUri*/</span>,
            blobClient <span style="color: green">/*serviceClient*/</span>);
 
        <span style="color: #2b91af">CloudBlob </span>destinationVideo = <span style="color: blue">new </span><span style="color: #2b91af">CloudBlob</span>(
            destinationVideoBlobUri <span style="color: green">/*blobUri*/</span>,
            blobClient <span style="color: green">/*serviceClient*/</span>);
        
        <span style="color: green">// Create the SAS policies for the videos
        // The permissions are restricted to read-only for the source 
        // and write-only for the destination.
        </span>SharedAccessBlobPolicy sourcePolicy = <span style="color: blue">new </span>SharedAccessBlobPolicy
        {
            <span style="color: green">// Allow 24 hours for reading and transcoding the video
            </span>SharedAccessExpiryTime = DateTime.UtcNow.AddHours(24),
            Permissions = SharedAccessBlobPermissions.Read
        };
 
        SharedAccessBlobPolicy destinationPolicy = <span style="color: blue">new </span>SharedAccessBlobPolicy
        {
            <span style="color: green">// Allow 24 hours for reading and transcoding the video
            </span>SharedAccessExpiryTime = DateTime.UtcNow.AddHours(24),
            Permissions = SharedAccessBlobPermissions.Write
        };
 
        <span style="color: green">// Generate SAS tokens for the source and destination
        </span><span style="color: blue">string </span>sourceSasToken = sourceVideo.GetSharedAccessSignature(
            sourcePolicy,
            <span style="color: blue">null </span><span style="color: green">/* access policy identifier */</span>);
 
        <span style="color: blue">string </span>destinationSasToken = destinationVideo.GetSharedAccessSignature(
            destinationPolicy,
            <span style="color: blue">null </span><span style="color: green">/* access policy identifier */</span>);
 
        <span style="color: green">// Create a workitem for transcoding the video
        </span>TranscodingWorkItem workItem = <span style="color: blue">new </span>TranscodingWorkItem
        {
            SourceVideoUri = sourceVideo.Uri.AbsoluteUri,
            DestinationVideoUri = destinationVideo.Uri.AbsoluteUri,
            SourceSasToken = sourceSasToken,
            DestinationSasToken = destinationSasToken,
            TargetVideoQuality = videoQuality
        };
 
        <span style="color: green">// Get the credentials for the service queue. This would use the cached
        // credentials in case they did not expire, otherwise it would contact the
        // video processing service
        </span><span style="color: #2b91af">StorageCredentials </span>serviceQueueSasCrendials = GetServiceQueueSasCredentials();
        <span style="color: #2b91af">CloudQueueClient </span>queueClient = <span style="color: blue">new </span><span style="color: #2b91af">CloudQueueClient</span>(
            <span style="color: blue">this</span>.serviceQueueEndpoint <span style="color: green">/*baseAddress*/</span>,
            serviceQueueSasCrendials <span style="color: green">/*credentials*/</span>);
 
        <span style="color: #2b91af">CloudQueue </span>serviceQueue = queueClient.GetQueueReference(<span style="color: #2b91af">SasProducer</span>.WorkerQueueName);
 
        <span style="color: green">// Add the workitem to the queue which would 
        // result in a Put Message API to be called on a SAS URL
        </span><span style="color: #2b91af">CloudQueueMessage </span>message = <span style="color: blue">new </span><span style="color: #2b91af">CloudQueueMessage</span>(
            workItem.ToMessage() <span style="color: green">/*content*/</span>);
        serviceQueue.AddMessage(message);
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Gets the SAS storage credentials object for accessing 
    </span><span style="color: gray">/// </span><span style="color: green">the video processing queue.
    </span><span style="color: gray">/// </span><span style="color: green">This method will automatically refresh the credentials as needed.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public </span><span style="color: #2b91af">StorageCredentials </span>GetServiceQueueSasCredentials()
    {
        <span style="color: green">// Refresh the credentials if needed.
        </span><span style="color: blue">if </span>(<span style="color: blue">this</span>.serviceQueueSasCredentials == <span style="color: blue">null </span>||
            DateTime.UtcNow.AddMinutes(CredsRefreshThresholdInMinutes) 
                &gt;= <span style="color: blue">this</span>.serviceQueueSasExpiryTime)
        {
            <span style="color: blue">this</span>.RefreshAccessCredentials();
        }
 
        <span style="color: blue">return this</span>.serviceQueueSasCredentials;
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Request a new SAS token from the service, and updates the 
    </span><span style="color: gray">/// </span><span style="color: green">cached credentials and the expiration time.
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;returns&gt;</span><span style="color: green">True if the credentials were refreshed, false otherwise.</span><span style="color: gray">&lt;/returns&gt;
    </span><span style="color: blue">public void </span>RefreshAccessCredentials()
    {
        <span style="color: green">// Request the SAS token. This is currently emulated as a 
        // method call against the SasProducer object
 
        </span><span style="color: blue">string </span>sasToken = <span style="color: blue">this</span>.videoProcessingService.GetClientSasToken();
 
        <span style="color: green">// Create credentials using the new token.
        </span><span style="color: blue">this</span>.serviceQueueSasCredentials = <span style="color: blue">new </span><span style="color: #2b91af">StorageCredentialsSharedAccessSignature</span>(sasToken);
        <span style="color: blue">this</span>.serviceQueueSasExpiryTime = DateTime.UtcNow.Add(<span style="color: #2b91af">SasProducer</span>.SasTokenDuration);
    }
}</pre>
<p>We then look at the video processing worker role code. The code uses SAS tokens that can either be passed in as part of a configuration file or the video processing role could contact the SAS Producer role to get such info.</p>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">A class representing a video processing worker role
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">public class </span><span style="color: #2b91af">VideoProcessingWorker
</span>{
    <span style="color: blue">public const string </span>WorkerQueueName = <span style="color: #a31515">&quot;videoprocessingqueue&quot;</span>;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">A reference to the video processing queue
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private </span><span style="color: #2b91af">CloudQueue </span>videoProcessingQueue;
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Initializes a new instance of the VideoProcessngWorker class.
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;sasTokenForWorkQueue&quot;&gt;
    /// </span><span style="color: green">The SAS token for accessing the work queue.</span><span style="color: gray">&lt;/param&gt;
    /// &lt;param name=&quot;storageAccountName&quot;&gt;
    /// </span><span style="color: green">The storage account name used by this service</span><span style="color: gray">&lt;/param&gt;
    </span><span style="color: blue">public </span>VideoProcessingWorker(<span style="color: blue">string </span>sasTokenForWorkQueue, <span style="color: blue">string </span>storageAccountName)
    {
        <span style="color: blue">string </span>queueEndpoint = 
            <span style="color: blue">string</span>.Format(<span style="color: #a31515">&quot;http://{0}.queue.core.windows.net&quot;</span>, storageAccountName);
 
        <span style="color: #2b91af">StorageCredentials </span>queueCredendials = 
            <span style="color: blue">new </span><span style="color: #2b91af">StorageCredentialsSharedAccessSignature</span>(sasTokenForWorkQueue);
        <span style="color: #2b91af">CloudQueueClient </span>queueClient = 
            <span style="color: blue">new </span><span style="color: #2b91af">CloudQueueClient</span>(queueEndpoint, queueCredendials);
        <span style="color: blue">this</span>.videoProcessingQueue = 
            queueClient.GetQueueReference(<span style="color: #2b91af">VideoProcessingWorker</span>.WorkerQueueName);
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Starts the worker, which polls the queue for messages containing videos to be transcoded.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public void </span>Start()
    {
        <span style="color: blue">while </span>(<span style="color: blue">true</span>)
        {
            <span style="color: green">// Get a message from the queue by setting an initial visibility timeout to 5 minutes
            </span><span style="color: #2b91af">CloudQueueMessage </span>message = <span style="color: blue">this</span>.videoProcessingQueue.GetMessage(
                TimeSpan.FromMinutes(5) <span style="color: green">/*visibilityTimeout*/</span>);
 
            <span style="color: green">// If there are no messages, sleep and retry.
            </span><span style="color: blue">if </span>(message == <span style="color: blue">null</span>)
            {
                Thread.Sleep(TimeSpan.FromSeconds(5));
                <span style="color: blue">continue</span>;
            }
 
            TranscodingWorkItem workItem;
 
            <span style="color: blue">try
            </span>{
                <span style="color: green">// Deserialize the work item
                </span>workItem = TranscodingWorkItem.FromMessage(message.AsString);
            }
            <span style="color: blue">catch </span>(InvalidOperationException)
            {
                <span style="color: green">// The message is malformed
                // Log an error (or an alert) and delete it from the queue
                </span><span style="color: blue">this</span>.videoProcessingQueue.DeleteMessage(message);
                <span style="color: blue">continue</span>;
            }
 
            <span style="color: green">// Create the source and destination CloudBlob objects
            // from the workitem's blob uris and sas tokens
            </span><span style="color: #2b91af">StorageCredentials </span>sourceCredentials = 
                <span style="color: blue">new </span><span style="color: #2b91af">StorageCredentialsSharedAccessSignature</span>(workItem.SourceSasToken);
            <span style="color: #2b91af">CloudBlob </span>sourceVideo = <span style="color: blue">new </span><span style="color: #2b91af">CloudBlob</span>(workItem.SourceVideoUri, sourceCredentials);
 
            <span style="color: #2b91af">StorageCredentials </span>destinationCredentials = 
                <span style="color: blue">new </span><span style="color: #2b91af">StorageCredentialsSharedAccessSignature</span>(workItem.DestinationSasToken);
            <span style="color: #2b91af">CloudBlob </span>destinationVideo = 
                <span style="color: blue">new </span><span style="color: #2b91af">CloudBlob</span>(workItem.DestinationVideoUri, destinationCredentials);
 
            <span style="color: green">// Process the video
            </span><span style="color: blue">this</span>.ProcessVideo(sourceVideo, destinationVideo, workItem.TargetVideoQuality);
 
            <span style="color: green">// Delete the message from the queue.
            </span><span style="color: blue">this</span>.videoProcessingQueue.DeleteMessage(message);
        }
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Transcodes the video.
    </span><span style="color: gray">/// </span><span style="color: green">This does not do any actual video processing.
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">private void </span>ProcessVideo(
        <span style="color: #2b91af">CloudBlob </span>sourceVideo,
        <span style="color: #2b91af">CloudBlob </span>destinationVideo,
        VideoQuality targetVideoQuality)
    {
        <span style="color: #2b91af">Stream </span>inStream = sourceVideo.OpenRead();
        <span style="color: #2b91af">Stream </span>outStream = sourceVideo.OpenWrite();
 
        <span style="color: green">// This is where the real work is done.
        // In this example, we just write inStream to outStream plus some extra text.
 
        </span><span style="color: blue">byte</span>[] buffer = <span style="color: blue">new byte</span>[1024];
        <span style="color: blue">int </span>count = 1;
 
        <span style="color: blue">while </span>(count != 0)
        {
            count = inStream.Read(buffer, 0, buffer.Length);
            outStream.Write(buffer, 0, count);
        }
 
        <span style="color: green">// Write the extra text
        </span><span style="color: blue">using </span>(<span style="color: #2b91af">TextWriter </span>writer = <span style="color: blue">new </span><span style="color: #2b91af">StreamWriter</span>(outStream))
        {
            writer.WriteLine(<span style="color: #a31515">&quot; (transcoded to {0})&quot;</span>, targetVideoQuality);
        }
    }
}</pre>
<p>For completion, we are providing the following Main method code that would allow you to test the above sample code.</p>
<p><a href="http://11011.net/software/vspaste"></a></p>
<pre class="code"><span style="color: blue">public static void </span>Main()
{
    <span style="color: blue">string </span>serviceAccountName = <span style="color: #a31515">&quot;someserviceaccountname&quot;</span>;
    <span style="color: blue">string </span>serviceAccountKey = <span style="color: #a31515">&quot;someserviceAccountKey&quot;</span>;
 
    <span style="color: blue">string </span>serviceQueueEndpoint = 
        <span style="color: blue">string</span>.Format(<span style="color: #a31515">&quot;http://{0}.queue.core.windows.net&quot;</span>, serviceAccountName);
 
    <span style="color: green">// Set up the SAS producer as part of the fron-end
    </span>SasProducer sasProducer = <span style="color: blue">new </span>SasProducer(serviceAccountName, serviceAccountKey);
 
    <span style="color: green">// Get the SAS token for max time period that is used by the service worker role
    </span><span style="color: blue">string </span>sasTokenForQueue = sasProducer.GetSasTokenForProcessingMessages();
 
    <span style="color: green">// Start the video processing worker
    </span>VideoProcessingWorker transcodingWorker = 
        <span style="color: blue">new </span>VideoProcessingWorker(sasTokenForQueue, <span style="color: #a31515">&quot;someAccountName&quot;</span>);
    ThreadPool.QueueUserWorkItem((state) =&gt; transcodingWorker.Start());
 
    <span style="color: green">// Set up the client library
    </span>Client client = <span style="color: blue">new </span>Client(sasProducer, serviceQueueEndpoint);
 
    <span style="color: green">// Use the client libary to submit transcoding workitems
    </span><span style="color: blue">string </span>customerAccountName = <span style="color: #a31515">&quot;clientaccountname&quot;</span>;
    <span style="color: blue">string </span>customerAccountKey = <span style="color: #a31515">&quot;CLIENTACCOUNTKEY&quot;</span>;
 
    CloudStorageAccount storageAccount = CloudStorageAccount.Parse(
        <span style="color: blue">string</span>.Format(<span style="color: #a31515">&quot;DefaultEndpointsProtocol=http;AccountName={0};AccountKey={1}&quot;</span>,
        customerAccountName,
        customerAccountKey));
 
    CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
    
    <span style="color: green">// Create a source container
    </span>CloudBlobContainer sourceContainer = 
        blobClient.GetContainerReference(<span style="color: #a31515">&quot;sourcevideos&quot;</span>);
    sourceContainer.CreateIfNotExist();
 
    <span style="color: green">// Create destination container
    </span>CloudBlobContainer destinationContainer = 
        blobClient.GetContainerReference(<span style="color: #a31515">&quot;transcodedvideos&quot;</span>);
    destinationContainer.CreateIfNotExist();
 
    List&lt;CloudBlob&gt; sourceVideoList = <span style="color: blue">new </span>List&lt;CloudBlob&gt;();
 
    <span style="color: green">// Upload 10 source videos
    </span><span style="color: blue">for </span>(<span style="color: blue">int </span>i = 0; i &lt; 10; i++)
    {
        CloudBlob sourceVideo = sourceContainer.GetBlobReference(<span style="color: #a31515">&quot;Video&quot; </span>+ i);
 
        <span style="color: green">// Upload the video
        // This example uses a placeholder string
        </span>sourceVideo.UploadText(<span style="color: #a31515">&quot;Content of video&quot; </span>+ i);
 
        sourceVideoList.Add(sourceVideo);
    }
             
    <span style="color: green">// Submit Video Processing Requests to the service using Queue SAS
    </span><span style="color: blue">for </span>(<span style="color: blue">int </span>i = 0; i &lt; 10; i++)
    {
        CloudBlob sourceVideo = sourceVideoList[i];
        CloudBlob destinationVideo = 
            destinationContainer.GetBlobReference(<span style="color: #a31515">&quot;Video&quot; </span>+ i);
 
        client.SubmitTranscodeVideoRequest(
            customerAccountName,
            customerAccountKey,
            sourceVideo.Uri.AbsoluteUri,
            destinationVideo.Uri.AbsoluteUri,
            VideoQuality.quality480p);
    }
 
    <span style="color: green">// Let the worker finish processing
    </span>Thread.Sleep(TimeSpan.FromMinutes(5));
}</pre>
<p>Jean Ghanem, Michael Roberson, Weiping Zhang, Jai Haridas, Brad Calder </p>
<p><a href="http://11011.net/software/vspaste"></a></p>
	</div><!-- .entry-content -->


	<footer class="entry-footer single">
				<hr>
	</footer><!-- .entry-footer -->

</article><!-- #post-## -->

			
		</div><!-- #single-content -->

		
<div id="comments" class="comments-area">
	<div class="comments-title">
		Comments (9)	</div>

		<div id="respond" class="comment-respond">
		<h3 id="reply-title" class="comment-reply-title"> <small><a rel="nofollow" id="cancel-comment-reply-link" href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#respond" style="display:none;">Cancel reply</a></small></h3><p class="must-log-in">You must be <a href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2012%2F06%2F12%2Fintroducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas%2F">logged in</a> to post a comment.</p>	</div><!-- #respond -->
	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-155">
				<div id="div-comment-155" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Vin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#comment-155">
			July 18, 2012 at 4:49 am</a>		</div>

		<p>Git doesn&#39;t contain the sample code. </p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2012%2F06%2F12%2Fintroducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-156">
				<div id="div-comment-156" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">jaidevh1@hotmail.com</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#comment-156">
			July 26, 2012 at 12:09 pm</a>		</div>

		<p>@Vin &#8211; we are still working on an appropriate place to publish samples associated with blogs. But until then, we have the entire source code in the blog.</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2012%2F06%2F12%2Fintroducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-158">
				<div id="div-comment-158" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Andy</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#comment-158">
			August 5, 2012 at 6:09 am</a>		</div>

		<p>Is it possible to use Table SAS directly from javascript in a browser ie. addressing cross domain issues?</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2012%2F06%2F12%2Fintroducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-160">
				<div id="div-comment-160" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">jws</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#comment-160">
			August 8, 2012 at 4:45 pm</a>		</div>

		<p>when do you expect to release the changes to the storage client library? i&#39;m assuming the changes for shared access signatures are not reflected in the recent 1.7 update.</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2012%2F06%2F12%2Fintroducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-166">
				<div id="div-comment-166" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">jaidevh1@hotmail.com</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#comment-166">
			August 19, 2012 at 12:56 am</a>		</div>

		<p>@jws, 1.7 still uses the 2011-08-18 REST version. We have released source code as mentioned in this post and we will make available our 2.0 library in the next month or so. The 2.0 library will support 2012-02-12 version of REST.</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2012%2F06%2F12%2Fintroducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-167">
				<div id="div-comment-167" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">jaidevh1@hotmail.com</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#comment-167">
			August 19, 2012 at 12:58 am</a>		</div>

		<p>@Andy, it will not be possible yet since Azure Storage service does not support CORS headers. However, it is already documented in the list of feature requests.</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2012%2F06%2F12%2Fintroducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment byuser comment-author-srigopal_saihotmail-com even thread-even depth-1" id="comment-214">
				<div id="div-comment-214" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://i1.social.s-msft.com/profile/u/avatar.jpg?displayname=Srigopal+Chitrapu&amp;size=extralarge&amp;version=fa441690-4928-498a-b1e5-5b82144c2240" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn"><a href="https://social.msdn.microsoft.com/profile/Srigopal+Chitrapu" rel="external nofollow" class="url">Srigopal Chitrapu</a></cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#comment-214">
			December 1, 2012 at 3:54 pm</a>		</div>

		<p>Good Article.</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2012%2F06%2F12%2Fintroducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-218">
				<div id="div-comment-218" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/f262da27505d44475e5a86045bdc3483?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/f262da27505d44475e5a86045bdc3483?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">clouddvtestbot@live.com</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#comment-218">
			December 4, 2012 at 10:27 am</a>		</div>

		<p>I dont see a link for the sample download. Where can I find it?</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2012%2F06%2F12%2Fintroducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-219">
				<div id="div-comment-219" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Jean Ghanem</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas/#comment-219">
			December 5, 2012 at 9:15 pm</a>		</div>

		<p>@CloudDv, the sample code is provided inline as part of the blog. The Github link is for downloading the SDK. The latest SDK can now be found at <a rel="nofollow" target="_new" href="https://github.com/WindowsAzure/azure-sdk-for-net">github.com/&#8230;/azure-sdk-for-net</a> , <a rel="nofollow" target="_new" href="http://www.windowsazure.com/en-us/develop/net/">http://www.windowsazure.com/&#8230;/net</a> or <a rel="nofollow" target="_new" href="http://nuget.org/packages/WindowsAzure.Storage">nuget.org/&#8230;/WindowsAzure.Storage</a></p>
<p>Thanks,</p>
<p>Jean</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2012%2F06%2F12%2Fintroducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
	
</div><!-- .comments-area -->
	</div><!-- #primary -->