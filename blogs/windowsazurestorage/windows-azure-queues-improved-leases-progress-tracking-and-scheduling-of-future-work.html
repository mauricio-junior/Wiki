---
layout: windowsazurestorage
title: Windows Azure Queues&#58; Improved Leases, Progress Tracking, and Scheduling of Future Work
weight: 3
---

<div id="site-content" class="site-content row">

	<div id="primary" class="content-area col-sm-9">
		<div id="single-content" class="div-content">

			
				
<article id="post-60" class="post-60 post type-post status-publish format-standard hentry category-uncategorized tag-windows-azure-queues">

	<header class="entry-header single">
		<h1 class="entry-title">Windows Azure Queues: Improved Leases, Progress Tracking, and Scheduling of Future Work</h1>		<div class="rating-wrap">
		<div id="star-rating-60" class="wds-ratings" data-rating="4" data-userrating="0" data-postid="60" data-container="body" data-toggle="tooltip" title="2 user(s) rated">
			<div class="wds-ratings-inner-wrap">
				<div>
					<div aria-label="Select 5 star, this article is 4 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="5"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span><span aria-hidden="true" class="star-4"><span>&#x2605;</span></span><span aria-hidden="true" class="star-5"><span>&#x2605;</span></span></div><div aria-label="Select 4 star, this article is 4 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="4"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span><span aria-hidden="true" class="star-4"><span>&#x2605;</span></span></div><div aria-label="Select 3 star, this article is 4 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="3"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span></div><div aria-label="Select 2 star, this article is 4 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="2"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span></div><div aria-label="Select 1 star, this article is 4 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="1"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span></div>
				</div>
			</div>
		</div>
		</div>		<div class="clear-both"></div>
		<div class="entry-meta">
			<img alt="avatar of windows-azure-storage" src="https://i1.social.s-msft.com/profile/u/avatar.jpg?displayname=Windows+Azure+Storage&amp;size=extralarge&amp;version=00000000-0000-0000-0000-000000000000" class="avatar avatar-22 photo" height="22" width="22"/><span class="byline"><span class="author vcard"><a class="url fn n profile-usercard-hover" data-profile-userid="59e1aedafa2d4428b7004b2c2fac4adc" href="https://social.msdn.microsoft.com/profile/Windows+Azure+Storage">Windows Azure Storage</a></span></span><span class="posted-on posted-on-margin"><span class="screen-reader-text"></span><time class="entry-date published updated" datetime="2011-09-15T13:26:00+00:00">September 15, 2011</time></span><span class="comments-link"><span class="glyphicon glyphicon-comment" aria-hidden="true"></span><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/#comments">8</a></span>				<span class="social-icons-wrap">
		<ul class="social-icons">
			<li><div class="fb-share-button" data-href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/" data-layout="button_count" data-size="large" data-mobile-iframe="true"><a class="fb-xfbml-parse-ignore" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/&amp;src=sdkpreparse">Share</a></div></li>
			<div id="fb-root" style="display:none"></div>

			<li class="social-icon twitter"><a data-social="{&quot;type&quot;:&quot;twitter&quot;, &quot;url&quot;:&quot;https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/&quot;, &quot;text&quot;: &quot;Windows Azure Queues: Improved Leases, Progress Tracking, and Scheduling of Future Work&quot;}" href="#" id="post_tweet_count">0</a></li>
			<li class="social-icon linkedin"><a data-social="{&quot;type&quot;:&quot;linkedin&quot;, &quot;url&quot;:&quot;https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/&quot;, &quot;text&quot;: &quot;Windows Azure Queues: Improved Leases, Progress Tracking, and Scheduling of Future Work&quot;}" href="#" id="get_post_linkedin_count">0</a></li>
		</ul>
	</span><!-- .social-icons-wrap -->
	<script type="text/javascript">
		// Get social counts
		jQuery( window ).load(function () {
			jQuery.getScript('https://blogs.msdn.microsoft.com/windowsazurestorage/wp-content/themes/microsoft/js/social-counts.js?ver=02092017')
				.done(function(script,textStatus) {
					window.msdnsocial.ajax('https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/');
				});
		});
	</script>
		</div>
		<hr>
	</header><!-- .entry-header -->

	<div class="entry-content single">
		<p>As part of the “2011-08-18” version, we have introduced several commonly requested features to the Windows Azure Queue service. The benefits of these new features are: </p>
<ol>
<li>Allow applications to store larger messages </li>
<li>Allow applications to schedule work to be processed at a later time </li>
<li>Allow efficient processing for long running tasks, by adding:
<ul>
<li>Leasing: Processing applications can now extend the visibility timeout on a message they have dequeued and hence maintain a lease on the message </li>
<li>Progress Tracking: Processing applications can update the message content of a message they have dequeued to save progress state so that a new worker can continue from that state if the prior worker crashed.</li>
</ul>
</li>
</ol>
<h4>That was then</h4>
<p>To better understand these features, let us quickly summarize the messaging semantics in Windows Azure Queue. The Windows Azure Queue service provides a scalable message delivery system that can be used to build workflow and decouple components that need to communicate. With the 2009-09-19 version of the service, users could add up to 8KB messages into the queue. When adding a message, users specify a time to live (&lt; 7 days) after which the message is automatically deleted if it still exists in the queue. When added to the queue, a message is visible and a candidate to be dequeued to be processed by workers. Workers use a 2-phase dequeue/delete pattern. This semantic required the workers to estimate the time it would take to process the message at the time of message is retrieved, often referred to as a non-renewable lease period of the message called the “visibility timeout”. This non-renewable lease period had a limit of 2 hours. When the message is retrieved, a unique token called a pop receipt is associated with the message and must be used for subsequent operations on the message. Once the message is retrieved from the Queue, the message becomes invisible in the queue. When a message is completely processed, the worker subsequently issues a request to delete the message using the pop receipt. This 2-phase process ensures that a message is available to another worker if the initial worker crashes while processing the message. </p>
<h4>This is now</h4>
<p>With the 2011-08-18 version, we focused on streamlining the use of Windows Azure Queues to make them simpler and more efficient. First, we made it extremely simple for workers to process long running jobs efficiently – this required the ability to extend the lease on the message by providing a new visibility timeout. Without this ability, workers would have had to provide a generous lease period to the “<a href="http://msdn.microsoft.com/en-us/library/dd179474.aspx">Get Messages</a>” API since the lease period is set before the message is inspected. </p>
<p>To further improve efficiency, we now allow workers to also update the message contents they have dequeued. This can be used to store progress information and intermittent states so that if the worker crashes, a new worker can resume the work rather than starting from scratch. Finally, we targeted scenarios that allow support for larger messages and allow scheduling of work when adding messages to the queue. To reiterate, the following features in the 2011-08-18 version, makes working with Windows Azure Queues simpler and more efficient: </p>
<ol>
<li>The maximum message size has been increased to 64KB which will allow more applications to store the full message in the queue, instead of storing the actual message contents in blobs, and to now keep progress information in the message. </li>
<li>A message can be added to the queue with a visibility timeout so that it becomes visible to workers at a later time. </li>
<li>A lease on the message can be extended by the worker that did the original dequeue so that it can continue processing the message. </li>
<li>The maximum visibilitytimeout for both scheduling future work, dequeueing a message, and updating it for leasing has been extended to 7 days. </li>
<li>The message content can now be updated to save the progress state, which allows other workers to resume processing the message without the need to start over from the beginning.</li>
</ol>
<p>NOTE: The current storage client library (version 1.5) uses the 2009-09-19 version and hence these new features are not available. We will be releasing an update with these new features in a future release of the SDK. Until that time we have provided some extension methods later in this posting that allow you to start using these new features today. </p>
<p>We will now go over the changes to the Windows Azure Queue service APIs in detail. </p>
<h4><a name="_Toc303490444">PUT Message</a></h4>
<p>The “<a href="http://msdn.microsoft.com/en-us/library/dd179346.aspx">PUT Message</a>” REST API is used to add messages to the queue. It now allows the message content to be up to 64KB and also provides an optional visibility timeout parameter. For example, you can now put a message into the queue with a visibilitytimeout of 24 hours, and the message will sit in the queue invisible until that time. Then at that time it will become visible for workers to process (along with the other messages in that queue). </p>
<p>By default, the visibilitytimeout used is 0 which implies that a message becomes visible for processing as soon as it is added to the queue. The visibilitytimeout is specified in seconds and must be &gt;= 0 and &lt; 604,800 (7 days). It also should be less than the “time to live”. Time to live has a default value of 7 days after which a message is automatically removed from the queue if it still exists. A message will be deleted from the queue after its time to live has been reached, regardless of whether it has become visible or not. </p>
<h5><a name="_Toc303490445">REST Examples</a></h5>
<p>Here is a REST example on how to add a message that will be visible in 10 minutes. The visibility timeout is provided as a query parameter to the URI called “visibilitytimeout” and is in seconds. The optional expiry time is provided as messagettl query parameter and is set in seconds here 2 days in this example. </p>
<p>Request:</p>
<pre class="code">POST http:<span style="color: green">//cohowinery.queue.core.windows.net/videoprocessing/messages?visibilitytimeout=600&amp;messagettl=172800&amp;timeout=30 HTTP/1.1
</span>x-ms-version: 2011-08-18
x-ms-date: Fri, 02 Sep 2011 05:03:21 GMT
Authorization: SharedKey cohowinery:sr8rIheJmCd6npMSx7DfAY3L<span style="color: green">//V3uWvSXOzUBCV9Ank=
</span>Content-Length: 100

&lt;QueueMessage&gt;
&lt;MessageText&gt;PHNhbXBsZT5zYW1wbGUgbWVzc2FnZTwvc2FtcGxlPg==&lt;/MessageText&gt;
&lt;/QueueMessage&gt;</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<h5><a name="_Toc303490446">Storage Client Library Example</a></h5>
<p>We will use the extension methods provided at the end of this blog to show how to add messages that are made visible at a later time. </p>
<p>Let us look at the scenario of a video processing workflow for Coho Winery. Videos are uploaded by the Marketing team at Coho Winery. Once these videos are uploaded, they need to be processed before it can be displayed on the Coho Winery web site – the workflow is: </p>
<ol>
<li>Scan for virus </li>
<li>Encode the video in multiple formats </li>
<li>Compress the video for efficiency and this is compressed to the new location that the website picks it up from.</li>
</ol>
<p>When uploading the videos initially, the component adds a message to the queue after the videos is uploaded. However, 1 day is allowed before the video is processed to allow a period of time for changes to be made to the video in the workflow. The message is appended to the queue with delayed visibility to allow this grace 1 day time period. A set of instructions go into the message which include the format, encoder to use, compression to use, scanners to use etc. The idea is that in addition to this information required for processing the message, we will also save the current state in the message. The format used is as follows; the first 2 characters represent the processing state, followed by the actual content.<br/>
  </p>
<pre class="code"><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">Add message for each blob in input directory. 
</span><span style="color: gray">/// </span><span style="color: green">After uploading, add a message to the queue with invisibility of 1 day 
</span><span style="color: gray">/// </span><span style="color: green">to allow the blob to be uploaded.
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">private static void </span>UploadVideos()
{
    <span style="color: #2b91af">CloudQueueClient </span>queueClient = Account.CreateCloudQueueClient();
    <span style="color: #2b91af">CloudQueue </span>queue = queueClient.GetQueueReference(QueueName);
    queue.EncodeMessage = <span style="color: blue">false</span>;

    <span style="color: blue">string</span>[] content = GetMessageContent();
    <span style="color: blue">for </span>(<span style="color: blue">int </span>i = 0; i &lt; content.Length; i++)
    {
        <span style="color: green">// upload the blob (not provided for brevity…)

        // Call the extension method provided at the end of this post
 </span>queue.PutMessage(
            Account.Credentials, 
            EncodeMessage(content[i], <span style="color: #2b91af">ProcessingState</span>.VirusScan),
            StartVisibilityTimeout, <span style="color: green">// set to 1 day
            </span>MessageTtl, <span style="color: green">// set to 3 days
            </span>ServerRequestTimeout);
        
    }
}

<span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">The processing stages for a message
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">public enum </span><span style="color: #2b91af">ProcessingState </span>: <span style="color: blue">int
</span>{
    VirusScan = 1,
    Encoder = 2,
    Compress = 3,
    Completed  = 4
}
<span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">Form of the queue message is: [2 digits for state][Actual Message content]
</span><span style="color: gray">/// &lt;/summary&gt;
/// &lt;param name=&quot;content&quot;&gt;&lt;/param&gt;
/// &lt;param name=&quot;state&quot;&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
</span><span style="color: blue">private static string </span>EncodeMessage(<span style="color: blue">string </span>content, <span style="color: #2b91af">ProcessingState </span>state)
{
    <span style="color: blue">return string</span>.Format(<span style="color: #a31515">&quot;{0:D2}{1}&quot;</span>, (<span style="color: blue">int</span>)state, content);
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<h4><a name="_Toc303490447">Update Message</a></h4>
<p>The “<a href="http://msdn.microsoft.com/en-us/library/hh452234.aspx">Update Message</a>” REST API is used to extend the lease period (aka visibility timeout) and/or update the message content. A worker that is processing a message can now determine the extra processing time it needs based on the content of a message. The lease period, specified in seconds, must be &gt;= 0 and is relative to the current time. 0 makes the message visible at that time in the queue as a candidate for processing. The maximum value for lease period is 7 days. Note, when updating the visibilitytimeout it can go beyond the expiry time (or time to live) that is defined when the message was added to the queue. But the expiry time will take precedence and the message will be deleted at that time from the queue. </p>
<p>Update Message can also be used by workers to store the processing state in the message. This processing state can then be used by another worker to resume processing if the former worker crashed or got interrupted and the message has not yet expired. </p>
<p>When getting a message, the worker gets back a pop-receipt. A valid pop-receipt is needed to perform any action on the message while it is invisible in the queue. The Update Message requires the pop receipt returned during the “<a href="http://msdn.microsoft.com/en-us/library/dd179474.aspx">Get Messages</a>” request or a previous Update Message. The pop receipt is invalid (400 HTTP status code) if: </p>
<ul>
<li>The message has expired. </li>
<li>The message has been deleted using the last pop receipt received either from “<a href="http://msdn.microsoft.com/en-us/library/dd179474.aspx">Get Messages</a>” or “<a href="http://msdn.microsoft.com/en-us/library/hh452234.aspx">Update Message</a>”. </li>
<li>The invisibility time has elapsed <b>and</b> the message has been retrieved by another “<a href="http://msdn.microsoft.com/en-us/library/dd179474.aspx">Get Messages</a>” call. </li>
<li>The message has been updated with a new visibility timeout and hence a new pop receipt is returned. Each time the message is updated, it gets a new pop-receipt which is returned with the UpdateMessage call.</li>
</ul>
<p>NOTE: When a worker goes to renew the lease (extend the visibility timeout), if for some reason the pop receipt is not received by the client (e.g., network error), the client can retry the request with the pop receipt it currently has. But if that retry fails with “Message not found” then the client should give up processing the message, and get a new message to process.&#160; This is because the prior message did have its visibility timeout extended, but it now has a new pop receipt, and that message will become visible again after the timeout elapses at which time a worker can dequeue it again and continue processing it. </p>
<p>The pop receipt returned in the response should be used for subsequent “<a href="http://msdn.microsoft.com/en-us/library/dd179347.aspx">Delete Message</a>” and “<a href="http://msdn.microsoft.com/en-us/library/hh452234.aspx">Update Message</a>” APIs. The new next visibility timeout is also returned in the response header. </p>
<h5><a name="_Toc303490448">REST Examples</a></h5>
<p>Update a message to set the visibility timeout to 1 minute. </p>
<pre class="code">PUT http:<span style="color: green">//cohowinery.queue.core.windosws.net/videoprocessing/messages/663d89aa-d1d9-42a2-9a6a-fcf822a97d2c?popreceipt=AgAAAAEAAAApAAAAGIw6Q29bzAE%3d&amp;visibilitytimeout=60&amp;timeout=30 HTTP/1.1
</span>x-ms-version: 2011-08-18
x-ms-date: Fri, 02 Sep 2011 05:03:21 GMT
Authorization: SharedKey cohowinery:batcrWZ35InGCZeTUFWMdIQiOZPCW7UEyeGdDOg7WW4=
Host: 10.200.21.10
<span style="color: #2b91af">Content</span>-Length: 75

&lt;QueueMessage&gt;&lt;MessageText&gt;<span style="color: blue">new</span>-message-content&lt;/MessageText&gt;&lt;/QueueMessage&gt;</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<h5><a name="_Toc303490449">Storage Client Library Example</a></h5>
<p>Continuing with the example of video processing workflow for Coho Winery, we will now go over the processing part of the workflow. The video processing task is a long running task and we would like to divide the work into stages defined by the ProcessingState enumeration mentioned above. The workflow is to retrieve a message, then decode its content to get the processing state and the actual content. To retrieve, we use the new extension method since the September 2009 version of GetMessage API blocked visibility timeouts of longer than 2 hours on the client side, and therefore won’t support this workflow. ProcessMessages starts a timer to iterate through all the current messages retrieved and renew the lease or delete the message based on the processing state and when the message will be visible again. ProcessMessages converts the QueueMessage retrieved into MessageInfo and adds it to the list of messages that needs to be renewed. The MessageInfo class exists since the QueueMessage class does not allow updating the pop receipt which needs to set on every Update message<a name="_GoBack"></a>.</p>
<pre class="code"><span style="color: blue">public class </span><span style="color: #2b91af">MessageInfo
</span>{
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Message info constructor
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;queue&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;messageId&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;popRceeipt&quot;&gt;&lt;/param&gt;
    </span><span style="color: blue">public </span>MessageInfo(
        <span style="color: #2b91af">CloudQueue </span>queue, 
        <span style="color: blue">string </span>messageId, 
        <span style="color: blue">string </span>popRceeipt, 
        <span style="color: blue">string </span>content, 
        ProcessingState state)
    {
        <span style="color: blue">this</span>.Queue = queue;
        <span style="color: blue">this</span>.MessageId = messageId;
        <span style="color: blue">this</span>.PopReceipt = popRceeipt;
        <span style="color: blue">this</span>.State = state;
        <span style="color: blue">this</span>.Content = content;
    }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">The queue to which the message belongs to
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public </span><span style="color: #2b91af">CloudQueue </span>Queue { <span style="color: blue">get</span>; <span style="color: blue">private set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">The message id  for the message
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public string </span>MessageId { <span style="color: blue">get</span>; <span style="color: blue">private set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">The pop receipt to use for update and delete
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public string </span>PopReceipt { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">The content of the message
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public string </span>Content { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Next visibility time
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public </span><span style="color: #2b91af">DateTime </span>NextVisibility { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }
 
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">The processing state the message is in. If completed, it will be 
    </span><span style="color: gray">/// </span><span style="color: green">deleted from the queue
    </span><span style="color: gray">/// &lt;/summary&gt;
    </span><span style="color: blue">public </span>ProcessingState State { <span style="color: blue">get</span>;  <span style="color: blue">set</span>; }
}

<span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">Called every minute to renew the lease
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">private static void </span>OnRenewLeaseTimer(<span style="color: blue">object </span>state)
{
    <span style="color: green">// Exception handling hidden for brevity...
 
    // traversing from last to allow deleting the message
    // from the list
    </span><span style="color: blue">for </span>( <span style="color: blue">int </span>i = MessageList.Count-1; i &gt;= 0; i--)
    {
        <span style="color: #2b91af">MessageInfo </span>message = MessageList[i];
 
        <span style="color: green">// if the message is completed - let us delete it
        </span><span style="color: blue">if</span>(message.State == ProcessingState.Completed)
        {
            message.Queue.DeleteMessage(message.MessageId, message.PopReceipt);
            <span style="color: #2b91af">Console</span>.WriteLine(
                <span style="color: #a31515">&quot;Deleted Message Id {0} to stage {1}&quot;</span>,
                message.MessageId,
                (<span style="color: blue">int</span>)message.State);
            MessageList.RemoveAt(i);
        }
        <span style="color: blue">else if </span>(
    message.NextVisibility.Subtract(<span style="color: #2b91af">DateTime</span>.UtcNow).TotalSeconds &lt; RenewalTime)
        {
            <span style="color: green">// if next visibility is &lt; renewal time then let us renew it again
            </span><span style="color: #2b91af">DateTime </span>nextVisibilityTime;
            <span style="color: blue">string </span>newPopReceipt;
 
            <span style="color: green">// based on whether we need to stop or not and the state, we will 
            // update the visibility
            // NOTE: we always update content but we can be smart about it and update only 
            // if state changes
            </span>message.Queue.UpdateMessage(
                Account.Credentials,
                message.MessageId,
                message.PopReceipt,
                VisibilityTimeout,
                EncodeMessage(message.Content, message.State),
                ServerRequestTimeout,
                <span style="color: blue">out </span>newPopReceipt,
                <span style="color: blue">out </span>nextVisibilityTime);
            message.PopReceipt = newPopReceipt;
            message.NextVisibility = nextVisibilityTime;
 
            <span style="color: #2b91af">Console</span>.WriteLine(
                <span style="color: #a31515">&quot;Updated Message Id {0} to stage {1} Next visible at {2}&quot;</span>, 
                message.MessageId, 
                (<span style="color: blue">int</span>)message.State, 
                nextVisibilityTime);
        }
    }
}
 

<span style="color: green">// NOTE: Exception handling is excluded here for brevity 
</span><span style="color: gray">/// &lt;summary&gt;
/// </span><span style="color: green">Processes a given number of messages. It iterates through stages and extends 
</span><span style="color: gray">/// </span><span style="color: green">visibility and saves state if it should continue processing.
</span><span style="color: gray">/// &lt;/summary&gt;
</span><span style="color: blue">private static void </span>ProcessMessages()
{    
<span style="color: #2b91af">CloudQueueClient </span>queueClient = Account.CreateCloudQueueClient();
 
    <span style="color: #2b91af">CloudQueue </span>queue = queueClient.GetQueueReference(QueueName);
    queue.EncodeMessage = <span style="color: blue">false</span>;
    
    <span style="color: #2b91af">Timer </span>timer = <span style="color: blue">new </span><span style="color: #2b91af">Timer</span>(<span style="color: blue">new </span>TimerCallback(OnRenewLeaseTimer), <span style="color: blue">null</span>, 0, TimerInterval);
 
    <span style="color: blue">while </span>(<span style="color: blue">true</span>)
    {
        QueueMessage message = queue.GetMessages(
            Account.Credentials,
            VisibilityTimeout,
            1 <span style="color: green">/* message count */</span>,
            ServerRequestTimeout).FirstOrDefault();
 
        <span style="color: blue">if </span>(message == <span style="color: blue">null</span>)
        {
            Thread.Sleep(PollingTime);
            <span style="color: blue">continue</span>;
        }
 
 
        <span style="color: blue">string </span>messageContent = message.Text;
        <span style="color: #2b91af">Console</span>.WriteLine(
            <span style="color: #a31515">&quot;\n\nGot message Content={0} Length={1} Id={2} InsertedAt={3} Visibility={4}&quot;</span>,
            messageContent, 
            messageContent.Length,
            message.Id, 
            message.InsertionTime, 
            message.TimeNextVisible);
 
        <span style="color: blue">string </span>content;
        ProcessingState state;
        DecodeMessage(messageContent, <span style="color: blue">out </span>content, <span style="color: blue">out </span>state);
        
   <span style="color: #2b91af">MessageInfo </span>msgInfo = <span style="color: blue">new </span><span style="color: #2b91af">MessageInfo</span>(
            queue, 
            message.Id, 
            message.PopReceipt, 
            content, 
            state);
        MessageList.Add( msgInfo );
 
        <span style="color: #2b91af">Console</span>.WriteLine(<span style="color: #a31515">&quot;Message Id {0} is in stage {1}&quot;</span>, message.Id, (<span style="color: blue">int</span>)state);
 
        <span style="color: green">// keep processing until we complete all stages of processing or 
        // we have next visibility &lt; UtcNow i.e. lease lost
        </span><span style="color: blue">while </span>(state != ProcessingState.Completed 
    &amp;&amp; msgInfo.NextVisibility &lt; <span style="color: #2b91af">DateTime</span>.UtcNow)
        {
            <span style="color: green">// do some work..
            </span>ProcessStage(msgInfo.MessageId, msgInfo.Content, <span style="color: blue">ref </span>state);
            msgInfo.State = state;
        }
    }
}</pre>
<pre>&#160;</pre>
<h4><a name="_Toc303490450">Get Messages</a></h4>
<p>The “<a href="http://msdn.microsoft.com/en-us/library/dd179474.aspx">Get Messages</a>” REST API is used to retrieve messages. The only change in 2011-08-18 version is that the visibility timeout has been extended from 2 hours to 7 days. </p>
<h5><a name="_Toc303490451">REST Examples</a></h5>
<p>Get messages with visibility timeout set to 4 hours (provided in seconds). </p>
<pre class="code">GET http:<span style="color: green">//cohowinery.queue.core.windosws.net/videoprocessing/messages? visibilitytimeout=14400&amp;timeout=30 HTTP/1.1
</span>x-ms-version: 2011-08-18
x-ms-date: Fri, 02 Sep 2011 05:03:21 GMT
Authorization: SharedKey cohowinery:batcrWZ35InGCZeTUFWMdIQiOZPCW7UEyeGdDOg7WW4=
Host: 10.200.21.10</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<h5><a name="_Toc303490452">Storage Client Library Example</a></h5>
<p>The example in Update Message covers the invocation of GetMessages extension. </p>
<h4><a name="_Toc303490453">Storage Client Library Extensions</a></h4>
<p>As we mentioned above, the existing Storage Client library released in SDK version 1.5 does not support the new version, therefore we have provided sample extension methods described in this blog post so you can start using these new features today. These extension methods can help you issue such requests. Please test this thoroughly before using it in production to ensure it meets your needs. </p>
<p>We have provided 2 extension methods: </p>
<ol>
<li>PutMessage: implements adding a message to the queue with visibility timeout. </li>
<li>UpdateMessage: implements updating a message (content and/or visibility timeout. It returns the new pop receipt and next visibility timeout. It does not change the CloudQueueMessage type, as pop receipt and next visibility are not publically accessible.<br/>
    </li>
</ol>
<pre class="code"><span style="color: blue">using </span>System;
<span style="color: blue">using </span>System.Collections.Generic;
<span style="color: blue">using </span>System.Linq;
<span style="color: blue">using </span>System.Text;
<span style="color: blue">using </span>System.Net;
<span style="color: blue">using </span>Microsoft.WindowsAzure.StorageClient.Protocol;
<span style="color: blue">using </span>System.IO;
<span style="color: blue">using </span>Microsoft.WindowsAzure;
<span style="color: blue">using </span>Microsoft.WindowsAzure.StorageClient;

<span style="color: green">// NOTE: Please test these before using in production
</span><span style="color: blue">public static class </span><span style="color: #2b91af">QueueExtensions
</span>{
    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Add a message to the queue. The visibility timeout param can be used to optionally 
    </span><span style="color: gray">/// </span><span style="color: green">make the message visible at a future time
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;queue&quot;&gt;
    /// </span><span style="color: green">The queue to add message to
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;credentials&quot;&gt;
    /// </span><span style="color: green">The storage credentials used for signing
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;message&quot;&gt;
    /// </span><span style="color: green">The message content
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;visibilityTimeout&quot;&gt;
    /// </span><span style="color: green">value in seconds and should be greater than or equal to 0 and less than 604800 (7 days). 
    </span><span style="color: gray">/// </span><span style="color: green">It should also be less than messageTimeToLive
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;messageTimeToLive&quot;&gt;
    /// </span><span style="color: green">(Optional) Time after which the message expires if it is not deleted from the queue.
    </span><span style="color: gray">/// </span><span style="color: green">It can be a maximum time of 7 days.
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;timeout&quot;&gt;
    /// </span><span style="color: green">Server timeout value
    </span><span style="color: gray">/// &lt;/param&gt;
    </span><span style="color: blue">public static void </span>PutMessage(
        <span style="color: blue">this </span><span style="color: #2b91af">CloudQueue </span>queue, 
        <span style="color: #2b91af">StorageCredentials </span>credentials, 
        <span style="color: blue">string </span>message, 
        <span style="color: blue">int</span>? visibilityTimeout, 
        <span style="color: blue">int</span>? messageTimeToLive,
        <span style="color: blue">int </span>timeout)
    {
        StringBuilder builder = <span style="color: blue">new </span>StringBuilder(queue.Uri.AbsoluteUri);

        builder.AppendFormat(<span style="color: #a31515">&quot;/messages?timeout={0}&quot;</span>, timeout);

        <span style="color: blue">if </span>(messageTimeToLive != <span style="color: blue">null</span>)
        {
            builder.AppendFormat(<span style="color: #a31515">&quot;&amp;messagettl={0}&quot;</span>, messageTimeToLive.ToString());
        }

        <span style="color: blue">if </span>(visibilityTimeout != <span style="color: blue">null</span>)
        {
            builder.AppendFormat(<span style="color: #a31515">&quot;&amp;visibilitytimeout={0}&quot;</span>, visibilityTimeout);
        }

        <span style="color: #2b91af">HttpWebRequest </span>request = (<span style="color: #2b91af">HttpWebRequest</span>)<span style="color: #2b91af">HttpWebRequest</span>.Create(builder.ToString());
        request.Method = <span style="color: #a31515">&quot;POST&quot;</span>;
        request.Headers.Add(<span style="color: #a31515">&quot;x-ms-version&quot;</span>, <span style="color: #a31515">&quot;2011-08-18&quot;</span>);

        <span style="color: blue">byte</span>[] buffer = QueueRequest.GenerateMessageRequestBody(message);

        request.ContentLength = buffer.Length;
        credentials.SignRequest(request); 
        <span style="color: blue">using </span>(Stream stream = request.GetRequestStream())
        {
            stream.Write(buffer, 0, buffer.Length);
        }

        <span style="color: blue">try
        </span>{
            <span style="color: blue">using</span>(<span style="color: #2b91af">HttpWebResponse </span>response = (<span style="color: #2b91af">HttpWebResponse</span>)request.GetResponse())
            {
                <span style="color: green">// we expect 201 for Put Message
                </span><span style="color: blue">if </span>(response.StatusCode != <span style="color: #2b91af">HttpStatusCode</span>.Created)
                {
                    <span style="color: blue">throw new </span><span style="color: #2b91af">InvalidOperationException</span>(<span style="color: #a31515">&quot;Unexpected response code.&quot;</span>);
                }
            }
        }
        <span style="color: blue">catch </span>(<span style="color: #2b91af">WebException </span>e)
        {
            <span style="color: green">// Log any exceptions for debugging
            </span>LogWebException(e);
            <span style="color: blue">throw</span>;
        }
    }

    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Update the message to extend visibility timeout and optionally 
    </span><span style="color: gray">/// </span><span style="color: green">the message contents 
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;queue&quot;&gt;
    /// </span><span style="color: green">The queue to operate on
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;credentials&quot;&gt;
    /// </span><span style="color: green">The storage credentials used for signing
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;messageId&quot;&gt;
    /// </span><span style="color: green">The ID of message to extend the lease on
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;popReceipt&quot;&gt;
    /// </span><span style="color: green">pop receipt to use
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;visibilityTimeout&quot;&gt;
    /// </span><span style="color: green">Value should be greater than or equal to 0 and less than 7. 
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;messageBody&quot;&gt;
    /// </span><span style="color: green">(optional) The message content
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;timeout&quot;&gt;
    /// </span><span style="color: green">Server timeout value
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;newPopReceiptID&quot;&gt;
    /// </span><span style="color: green">Return the new pop receipt that should be used for subsequent requests when 
    </span><span style="color: gray">/// </span><span style="color: green">the lease is held
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;nextVisibilityTime&quot;&gt;
    /// </span><span style="color: green">Return the next visibility time for the message. This is time until which the lease is held
    </span><span style="color: gray">/// &lt;/param&gt;
    </span><span style="color: blue">public static void </span>UpdateMessage(
        <span style="color: blue">this </span><span style="color: #2b91af">CloudQueue </span>queue, 
        <span style="color: #2b91af">StorageCredentials </span>credentials, 
        <span style="color: blue">string </span>messageId, 
        <span style="color: blue">string </span>popReceipt,
        <span style="color: blue">int </span>visibilityTimeout, 
        <span style="color: blue">string </span>messageBody,
        <span style="color: blue">int </span>timeout, 
        <span style="color: blue">out string </span>newPopReceiptID,
        <span style="color: blue">out </span><span style="color: #2b91af">DateTime </span>nextVisibilityTime)
    {
        StringBuilder builder = <span style="color: blue">new </span>StringBuilder(queue.Uri.AbsoluteUri);

        builder.AppendFormat(
            <span style="color: #a31515">&quot;/messages/{0}?timeout={1}&amp;popreceipt={2}&amp;visibilitytimeout={3}&quot;</span>, 
            messageId, 
            timeout, 
            <span style="color: #2b91af">Uri</span>.EscapeDataString(popReceipt),
            visibilityTimeout);

        <span style="color: #2b91af">HttpWebRequest </span>request = (<span style="color: #2b91af">HttpWebRequest</span>)<span style="color: #2b91af">HttpWebRequest</span>.Create(builder.ToString());
        request.Method = <span style="color: #a31515">&quot;PUT&quot;</span>;
        request.Headers.Add(<span style="color: #a31515">&quot;x-ms-version&quot;</span>, <span style="color: #a31515">&quot;2011-08-18&quot;</span>);

        <span style="color: blue">if </span>(messageBody != <span style="color: blue">null</span>)
        {
            <span style="color: blue">byte</span>[] buffer = QueueRequest.GenerateMessageRequestBody(messageBody);

            request.ContentLength = buffer.Length;
            credentials.SignRequest(request);
            <span style="color: blue">using </span>(Stream stream = request.GetRequestStream())
            {
                stream.Write(buffer, 0, buffer.Length);
            }
        }
        <span style="color: blue">else
        </span>{
            request.ContentLength = 0;
            credentials.SignRequest(request);
        }

        <span style="color: blue">try
        </span>{
            <span style="color: blue">using </span>(<span style="color: #2b91af">HttpWebResponse </span>response = (<span style="color: #2b91af">HttpWebResponse</span>)request.GetResponse())
            {
                <span style="color: blue">if </span>(response.StatusCode != <span style="color: #2b91af">HttpStatusCode</span>.NoContent)
                {
                    <span style="color: blue">throw new </span><span style="color: #2b91af">InvalidOperationException</span>(<span style="color: #a31515">&quot;Unexpected response code.&quot;</span>);
                }

                newPopReceiptID = response.Headers[<span style="color: #a31515">&quot;x-ms-popreceipt&quot;</span>];
                nextVisibilityTime = <span style="color: #2b91af">DateTime</span>.Parse(response.Headers[<span style="color: #a31515">&quot;x-ms-time-next-visible&quot;</span>]);
            }
        }
        <span style="color: blue">catch </span>(<span style="color: #2b91af">WebException </span>e)
        {
            <span style="color: green">// Log any exceptions for debugging
            </span>LogWebException(e);
            <span style="color: blue">throw</span>;
        }
    }


    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Get messages has been provided only because storage client library does not allow 
    </span><span style="color: gray">/// </span><span style="color: green">invisibility timeout to exceed 2 hours
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;queue&quot;&gt;
    /// </span><span style="color: green">The queue to operate on
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;credentials&quot;&gt;
    /// </span><span style="color: green">The storage credentials used for signing
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;messageId&quot;&gt;
    /// </span><span style="color: green">The ID of message to extend the lease on
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;popReceipt&quot;&gt;
    /// </span><span style="color: green">pop receipt to use
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;visibilityTimeout&quot;&gt;
    /// </span><span style="color: green">Value should be greater than or equal to 0 and less than 7. 
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;messageBody&quot;&gt;
    /// </span><span style="color: green">(optional) The message content
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;timeout&quot;&gt;
    /// </span><span style="color: green">Server timeout value
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;newPopReceiptID&quot;&gt;
    /// </span><span style="color: green">Return the new pop receipt that should be used for subsequent requests when 
    </span><span style="color: gray">/// </span><span style="color: green">the lease is held
    </span><span style="color: gray">/// &lt;/param&gt;
    /// &lt;param name=&quot;nextVisibilityTime&quot;&gt;
    /// </span><span style="color: green">Return the next visibility time for the message. This is time until which the lease is held
    </span><span style="color: gray">/// &lt;/param&gt;
    </span><span style="color: blue">public static </span><span style="color: #2b91af">IEnumerable</span>&lt;QueueMessage&gt; GetMessages(
        <span style="color: blue">this </span><span style="color: #2b91af">CloudQueue </span>queue,
        <span style="color: #2b91af">StorageCredentials </span>credentials,
        <span style="color: blue">int</span>? visibilityTimeout,
        <span style="color: blue">int</span>? messageCount,
        <span style="color: blue">int </span>timeout)
    {
        StringBuilder builder = <span style="color: blue">new </span>StringBuilder(queue.Uri.AbsoluteUri);

        builder.AppendFormat(
            <span style="color: #a31515">&quot;/messages?timeout={0}&quot;</span>,
            timeout);

        <span style="color: blue">if </span>(messageCount != <span style="color: blue">null</span>)
        {
            builder.AppendFormat(<span style="color: #a31515">&quot;&amp;numofmessages={0}&quot;</span>, messageCount);
        }

        <span style="color: blue">if </span>(visibilityTimeout != <span style="color: blue">null</span>)
        {
            builder.AppendFormat(<span style="color: #a31515">&quot;&amp;visibilitytimeout={0}&quot;</span>, visibilityTimeout);
        }

        <span style="color: #2b91af">HttpWebRequest </span>request = (<span style="color: #2b91af">HttpWebRequest</span>)<span style="color: #2b91af">HttpWebRequest</span>.Create(builder.ToString());
        request.Method = <span style="color: #a31515">&quot;GET&quot;</span>;
        request.Headers.Add(<span style="color: #a31515">&quot;x-ms-version&quot;</span>, <span style="color: #a31515">&quot;2011-08-18&quot;</span>);
        credentials.SignRequest(request);

        <span style="color: blue">try
        </span>{
            <span style="color: blue">using </span>(<span style="color: #2b91af">HttpWebResponse </span>response = (<span style="color: #2b91af">HttpWebResponse</span>)request.GetResponse())
            {
                <span style="color: blue">if </span>(response.StatusCode != <span style="color: #2b91af">HttpStatusCode</span>.OK)
                {
                    <span style="color: blue">throw new </span><span style="color: #2b91af">InvalidOperationException</span>(<span style="color: #a31515">&quot;Unexpected response code.&quot;</span>);
                }

                GetMessagesResponse msgResponses = QueueResponse.GetMessages(response);
                
                <span style="color: green">// force it to be parsed right away else the response will be closed
                // since QueueResponse.GetMessages parses responses lazily. 
                </span>QueueMessage[] messages = msgResponses.Messages.ToArray&lt;QueueMessage&gt;();
                <span style="color: blue">return </span>messages.AsEnumerable&lt;QueueMessage&gt;();
            }
        }
        <span style="color: blue">catch </span>(<span style="color: #2b91af">WebException </span>e)
        {
            <span style="color: green">// Log any exceptions for debugging
            </span>LogWebException(e);
            <span style="color: blue">throw</span>;
        }
    }

    <span style="color: gray">/// &lt;summary&gt;
    /// </span><span style="color: green">Log the exception in your preferred logging system
    </span><span style="color: gray">/// &lt;/summary&gt;
    /// &lt;param name=&quot;e&quot;&gt;
    /// </span><span style="color: green">The exception to log
    </span><span style="color: gray">/// &lt;/param&gt;
    </span><span style="color: blue">private static void </span>LogWebException(<span style="color: #2b91af">WebException </span>e)
    {
        <span style="color: #2b91af">HttpWebResponse </span>response = e.Response <span style="color: blue">as </span><span style="color: #2b91af">HttpWebResponse</span>;
        <span style="color: #2b91af">Console</span>.WriteLine(<span style="color: blue">string</span>.Format(
            <span style="color: #a31515">&quot;Request failed with '{0}'. Status={1} RequestId={2} Exception={3}&quot;</span>,
            e.Message,
            response.StatusCode,
            response != <span style="color: blue">null </span>? response.Headers[<span style="color: #a31515">&quot;x-ms-request-id&quot;</span>] : <span style="color: #a31515">&quot;&lt;NULL&gt;&quot;</span>,
            e.ToString()));

    <span style="color: green">// Log to your favorite location…
    
    </span>}
}</pre>
<p>Jai Haridas</p>
	</div><!-- .entry-content -->


	<footer class="entry-footer single">
					<div class="tags">
				<span>Tags </span>
				<span>
					<a href="https://blogs.msdn.microsoft.com/windowsazurestorage/tag/windows-azure-queues/" rel="tag">Windows Azure Queues</a>				</span>
			</div>
				<hr>
	</footer><!-- .entry-footer -->

</article><!-- #post-## -->

			
		</div><!-- #single-content -->

		
<div id="comments" class="comments-area">
	<div class="comments-title">
		Comments (8)	</div>

		<div id="respond" class="comment-respond">
		<h3 id="reply-title" class="comment-reply-title"> <small><a rel="nofollow" id="cancel-comment-reply-link" href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/#respond" style="display:none;">Cancel reply</a></small></h3><p class="must-log-in">You must be <a href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2011%2F09%2F15%2Fwindows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work%2F">logged in</a> to post a comment.</p>	</div><!-- #respond -->
	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-108">
				<div id="div-comment-108" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Vin</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/#comment-108">
			September 17, 2011 at 10:02 am</a>		</div>

		<p>I have been conducting a lot of Azure workshops, and just wanted to say a big thanks for these improvements !!. Customers will be very happy in my next boot camp . Kudos to the Storage team !</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2011%2F09%2F15%2Fwindows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-113">
				<div id="div-comment-113" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Ravi</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/#comment-113">
			September 19, 2011 at 9:23 am</a>		</div>

		<p>If the best practise to store large messages (&gt;64kb) is a combination of storing the key in the queue and the message in the BLOB, cant you make this as your internal implementation and drop the message size limitation for a message in the queue? </p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2011%2F09%2F15%2Fwindows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-117">
				<div id="div-comment-117" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">jaidevh1@hotmail.com</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/#comment-117">
			September 20, 2011 at 2:20 am</a>		</div>

		<p>@Ravi, Thanks for the feature request. We have noted it down in the list of feature requests to consider in the future. You can also look at using client side abstractions that makes this simpler (<a rel="nofollow" target="_new" href="http://windowsazurecat.com/2011/06/implementing-storage-abstraction-layer-to-support-very-large-messages-in-windows-azure-queues/?wpmp_switcher=mobile">windowsazurecat.com/&#8230;/implementing-storage-abstraction-layer-to-support-very-large-messages-in-windows-azure-queues</a>)</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2011%2F09%2F15%2Fwindows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-119">
				<div id="div-comment-119" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">ChrisL</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/#comment-119">
			September 21, 2011 at 7:02 pm</a>		</div>

		<p>@Ravi &#8211; My initial thoughts exactly when reading this blog</p>
<p>@Jai &#8211; Thanks for the link. &nbsp;Although the hyperlink is TL;DR, the conclusion looks promising and I&#39;ll review it more when I need queueing. &nbsp;I hope MSFT Eugne from PnP is using that code, seems like something of his quality.</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2011%2F09%2F15%2Fwindows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-124">
				<div id="div-comment-124" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Adar Wesley</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/#comment-124">
			November 13, 2011 at 8:44 am</a>		</div>

		<p>Hi,</p>
<p>Why isn&#39;t there a way to block on the GetMessage method until a message is available?</p>
<p>A blocking version of GetMessage with an optional timeout parameter would be very nice.</p>
<p>&#8212;</p>
<p>Adar Wesley</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2011%2F09%2F15%2Fwindows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-125">
				<div id="div-comment-125" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">jaidevh1@hotmail.com</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/#comment-125">
			November 13, 2011 at 10:35 am</a>		</div>

		<p>@Adar, thank you for the feedback. We will look at providing this functionality in the storage client library, to abstract that away.</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2011%2F09%2F15%2Fwindows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-128">
				<div id="div-comment-128" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Vikram</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/#comment-128">
			November 21, 2011 at 10:10 am</a>		</div>

		<p>I just downloaded the Nov 2011 release 1.6 Azure SDK and tried to use the UpdateMesasge method to update the content of a queue message. If i set the &#39;MessageUpdateFields&#39; to &#39;MessageUpdateFields.Content&#39; then it raises the exception &#39;Calls to UpdateMessage must include the Visibility flag&#39; and if I set it to &#39;MessageUpdateFields.Visibility&#39; it just dones not update the message contents. </p>
<p>Any idea what is going on?</p>
<p>Thanks.</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2011%2F09%2F15%2Fwindows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-129">
				<div id="div-comment-129" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/7baef01f55b96f7ef6e7d2270e0b7ec6?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">jaidevh1@hotmail.com</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2011/09/15/windows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work/#comment-129">
			November 21, 2011 at 3:53 pm</a>		</div>

		<p>@Vikram,</p>
<p>MessageUpdateFields enum is declared as flags. To update both content and visibility, have you tried setting it to:</p>
<p>MessageUpdateFields.Content | MessageUpdateFields.Visibility</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2011%2F09%2F15%2Fwindows-azure-queues-improved-leases-progress-tracking-and-scheduling-of-future-work%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
	
</div><!-- .comments-area -->
	</div><!-- #primary -->