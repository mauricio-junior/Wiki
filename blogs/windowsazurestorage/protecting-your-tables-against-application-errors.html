---
layout: windowsazurestorage
title: Protecting Your Tables Against Application Errors
weight: 3
---

<div id="site-content" class="site-content row">

	<div id="primary" class="content-area col-sm-9">
		<div id="single-content" class="div-content">

			
				
<article id="post-18" class="post-18 post type-post status-publish format-standard hentry category-uncategorized tag-windows-azure-tables">

	<header class="entry-header single">
		<h1 class="entry-title">Protecting Your Tables Against Application Errors</h1>		<div class="rating-wrap">
		<div id="star-rating-18" class="wds-ratings" data-rating="0" data-userrating="0" data-postid="18" data-container="body" data-toggle="tooltip" title="0 user(s) rated">
			<div class="wds-ratings-inner-wrap">
				<div>
					<div aria-label="Select 5 star, this article is 0 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="5"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span><span aria-hidden="true" class="star-4"><span>&#x2605;</span></span><span aria-hidden="true" class="star-5"><span>&#x2605;</span></span></div><div aria-label="Select 4 star, this article is 0 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="4"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span><span aria-hidden="true" class="star-4"><span>&#x2605;</span></span></div><div aria-label="Select 3 star, this article is 0 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="3"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span><span aria-hidden="true" class="star-3"><span>&#x2605;</span></span></div><div aria-label="Select 2 star, this article is 0 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="2"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span><span aria-hidden="true" class="star-2"><span>&#x2605;</span></span></div><div aria-label="Select 1 star, this article is 0 star rated" tabindex="0" class="wds-ratings-stars wds-ratings-stars-enable-editing" data-stars="1"><span aria-hidden="true" class="star-1"><span>&#x2605;</span></span></div>
				</div>
			</div>
		</div>
		</div>		<div class="clear-both"></div>
		<div class="entry-meta">
			<img alt="avatar of windows-azure-storage" src="https://i1.social.s-msft.com/profile/u/avatar.jpg?displayname=Windows+Azure+Storage&amp;size=extralarge&amp;version=00000000-0000-0000-0000-000000000000" class="avatar avatar-22 photo" height="22" width="22"/><span class="byline"><span class="author vcard"><a class="url fn n profile-usercard-hover" data-profile-userid="59e1aedafa2d4428b7004b2c2fac4adc" href="https://social.msdn.microsoft.com/profile/Windows+Azure+Storage">Windows Azure Storage</a></span></span><span class="posted-on posted-on-margin"><span class="screen-reader-text"></span><time class="entry-date published updated" datetime="2010-05-03T08:32:00+00:00">May 3, 2010</time></span><span class="comments-link"><span class="glyphicon glyphicon-comment" aria-hidden="true"></span><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/03/protecting-your-tables-against-application-errors/#comments">3</a></span>				<span class="social-icons-wrap">
		<ul class="social-icons">
			<li><div class="fb-share-button" data-href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/03/protecting-your-tables-against-application-errors/" data-layout="button_count" data-size="large" data-mobile-iframe="true"><a class="fb-xfbml-parse-ignore" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/03/protecting-your-tables-against-application-errors/&amp;src=sdkpreparse">Share</a></div></li>
			<div id="fb-root" style="display:none"></div>

			<li class="social-icon twitter"><a data-social="{&quot;type&quot;:&quot;twitter&quot;, &quot;url&quot;:&quot;https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/03/protecting-your-tables-against-application-errors/&quot;, &quot;text&quot;: &quot;Protecting Your Tables Against Application Errors&quot;}" href="#" id="post_tweet_count">0</a></li>
			<li class="social-icon linkedin"><a data-social="{&quot;type&quot;:&quot;linkedin&quot;, &quot;url&quot;:&quot;https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/03/protecting-your-tables-against-application-errors/&quot;, &quot;text&quot;: &quot;Protecting Your Tables Against Application Errors&quot;}" href="#" id="get_post_linkedin_count">0</a></li>
		</ul>
	</span><!-- .social-icons-wrap -->
	<script type="text/javascript">
		// Get social counts
		jQuery( window ).load(function () {
			jQuery.getScript('https://blogs.msdn.microsoft.com/windowsazurestorage/wp-content/themes/microsoft/js/social-counts.js?ver=02092017')
				.done(function(script,textStatus) {
					window.msdnsocial.ajax('https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/03/protecting-your-tables-against-application-errors/');
				});
		});
	</script>
		</div>
		<hr>
	</header><!-- .entry-header -->

	<div class="entry-content single">
		<p><p>“Do applications need to backup data in Windows Azure Storage if Windows Azure Storage already stores multiple replicas of the data?” For business continuity, it can be important to protect the data against errors in the application, which may erroneously modify the data.</p><br/>
<p>If there are problems at the application layer, the errors will get committed on the replicas that Windows Azure Storage maintains. So, to go back to the correct data, you will need to maintain a backup. Many application developers today have implemented their own backup strategy. The purpose of this post is to cover backup strategies for Tables.</p><br/>
<p>To backup tables, we would have to iterate through the list of tables and scan each table to copy the entities into blobs or a different destination table. Entity group transactions could then be used here to speed up the process of restoring entities from these blobs. Note, the example in this post is a full backup of the tables, and not a differential backup.</p><br/>
<h4>Table Backup</h4><br/>
<p>We will go over a simple full backup solution here. The strategy will be to take as input a list of tables and for each table a list of keys to use to partition the table scan. The list of keys will be converted into ranges such that separately backing up each of these ranges will provide a backup of the entire table. Breaking the backing up of the table into ranges this way allows the table to be backed up in parallel. The TableKeysInfo class will encapsulate the logic of splitting the keys into ranges as shown below:</p><pre class="code"><span style="COLOR: blue">public class </span><span style="COLOR: #2b91af">TableKeysInfo<br/>
</span>{<br/>
    <span style="COLOR: blue">private </span><span style="COLOR: #2b91af">List</span>&lt;PartitionKeyRange&gt; keyList = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">List</span>&lt;PartitionKeyRange&gt;();</p>
<p>    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">The table to backup<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    </span><span style="COLOR: blue">public string </span>TableName { <span style="COLOR: blue">get</span>; <span style="COLOR: blue">set</span>; }</p>
<p>    <span style="COLOR: blue">public </span>TableKeysInfo(<span style="COLOR: blue">string </span>tableName, <span style="COLOR: blue">string</span>[] keys)<br/>
    {<br/>
        <span style="COLOR: blue">if </span>(tableName == <span style="COLOR: blue">null</span>)<br/>
        {<br/>
            <span style="COLOR: blue">throw new </span><span style="COLOR: #2b91af">ArgumentNullException</span>(<span style="COLOR: #a31515">"tableName"</span>);<br/>
        }</p>
<p>        <span style="COLOR: blue">if </span>(keys == <span style="COLOR: blue">null</span>)<br/>
        {<br/>
            <span style="COLOR: blue">throw new </span><span style="COLOR: #2b91af">ArgumentNullException</span>(<span style="COLOR: #a31515">"keys"</span>);<br/>
        }</p>
<p>        <span style="COLOR: blue">this</span>.TableName = tableName;<br/>
        <span style="COLOR: green">// sort the keys<br/>
        </span><span style="COLOR: #2b91af">Array</span>.Sort&lt;<span style="COLOR: blue">string</span>&gt;(keys, <span style="COLOR: #2b91af">StringComparer</span>.InvariantCulture);</p>
<p>        <span style="COLOR: green">// split key list {A, M, X} into {[null-A), [A-M), [M-X), [X-null)}<br/>
        </span><span style="COLOR: blue">this</span>.keyList.Add(<span style="COLOR: blue">new </span>PartitionKeyRange(<span style="COLOR: blue">null</span>, keys.Length &gt; 0 ? keys[0] : <span style="COLOR: blue">null</span>));<br/>
        <span style="COLOR: blue">for </span>(<span style="COLOR: blue">int </span>i = 1; i &lt; keys.Length; i++)<br/>
        {<br/>
                <span style="COLOR: blue">this</span>.keyList.Add(<span style="COLOR: blue">new </span>PartitionKeyRange(keys[i - 1], keys[i]));<br/>
        }</p>
<p>        <span style="COLOR: blue">if </span>(keys.Length &gt; 0)<br/>
        {<br/>
            <span style="COLOR: blue">this</span>.keyList.Add(<span style="COLOR: blue">new </span>PartitionKeyRange(keys[keys.Length - 1], <span style="COLOR: blue">null</span>));<br/>
        }<br/>
    }</p>
<p>    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">The ranges of keys that will cover the entire table<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    </span><span style="COLOR: blue">internal </span><span style="COLOR: #2b91af">IEnumerable</span>&lt;PartitionKeyRange&gt; KeyRangeList<br/>
    {<br/>
        <span style="COLOR: blue">get<br/>
        </span>{<br/>
            <span style="COLOR: blue">return this</span>.keyList.AsEnumerable&lt;PartitionKeyRange&gt;();<br/>
        }<br/>
    }<br/>
}</pre><a href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></a><br/>
<p>BackupTables is the entry method into the backup process. The client can provide the TableKeysInfo for each table. For example if partition keys are GUIDs then here is how we can invoke the BackupTables method:</p><pre class="code"><span style="COLOR: #2b91af">CloudTableClient </span>tableClient = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">CloudTableClient</span>(account.TableEndpoint.AbsoluteUri, account.Credentials);<br/>
<span style="COLOR: #2b91af">CloudBlobClient </span>blobClient = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">CloudBlobClient</span>(account.BlobEndpoint.AbsoluteUri, account.Credentials);</p>
<p><span style="COLOR: green">// The more keys listed here, the better for scale<br/>
</span><span style="COLOR: blue">string</span>[] rangeQueries = <span style="COLOR: blue">new string</span>[] { <span style="COLOR: #a31515">"3"</span>, <span style="COLOR: #a31515">"8"</span>, <span style="COLOR: #a31515">"a"</span>, <span style="COLOR: #a31515">"f" </span>};<br/>
<span style="COLOR: blue">string</span>[] tableNames = <span style="COLOR: blue">new string</span>[] { <span style="COLOR: #a31515">"Customers"</span>, <span style="COLOR: #a31515">"Orders" </span>};</p>
<p><span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: #2b91af">TableKeysInfo</span>&gt; keyInfo = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: #2b91af">TableKeysInfo</span>&gt;();<br/>
<span style="COLOR: blue">foreach</span>(<span style="COLOR: blue">string </span>tableName <span style="COLOR: blue">in </span>tableNames)<br/>
{<br/>
     keyInfo.Add( <span style="COLOR: blue">new </span>TableKeysInfo(tableName, rangeQueries));<br/>
}</p>
<p>BackupTables(tableClient, blobClient, keyInfo);</pre><a href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></a><br/>
<p>The BackupTables now iterates through each table and for each range in the table, it invokes BackupTableRange which is responsible for saving the result set for the assigned range into a blob. For simplicity, we the example does this sequentially, but for faster backup you would want to parallelize the below to do the regions and tables in parallel.</p><pre class="code"><span style="COLOR: gray">/// &lt;summary&gt;<br/>
/// </span><span style="COLOR: green">Backup each table to blobs. Each table will be stored under a container with same name as the table.<br/>
</span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
/// &lt;param name="tableClient"&gt;&lt;/param&gt;<br/>
/// &lt;param name="blobClient"&gt;&lt;/param&gt;<br/>
/// &lt;param name="tablesToBackup"&gt;<br/>
/// </span><span style="COLOR: green">The tablesToBackup will contain the table name to a list of keys that will be used to partition the query<br/>
</span><span style="COLOR: gray">/// &lt;/param&gt;<br/>
</span><span style="COLOR: blue">public static void </span>BackupTables(<span style="COLOR: #2b91af">CloudTableClient </span>tableClient,<br/>
                   <span style="COLOR: #2b91af">CloudBlobClient </span>blobClient, <span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: #2b91af">TableKeysInfo</span>&gt; tablesToBackup)<br/>
{<br/>
    <span style="COLOR: blue">if </span>(tableClient == <span style="COLOR: blue">null</span>)<br/>
    {<br/>
        <span style="COLOR: blue">throw new </span><span style="COLOR: #2b91af">ArgumentNullException</span>(<span style="COLOR: #a31515">"tableClient"</span>);<br/>
    }</p>
<p>    <span style="COLOR: blue">try<br/>
    </span>{<br/>
        <span style="COLOR: green">// we will use this id as the folder name. The blobs will be stored under:<br/>
        //  &lt;lower cased table name&gt;/&lt;backupid&gt;/<br/>
        </span><span style="COLOR: blue">string </span>backupId = <span style="COLOR: #2b91af">DateTime</span>.UtcNow.ToString(<span style="COLOR: #a31515">"yy-MM-dd-HH-mm-ss"</span>);</p>
<p>        <span style="COLOR: green">// list each range in each table and backup up each range<br/>
        </span><span style="COLOR: blue">foreach </span>(<span style="COLOR: #2b91af">TableKeysInfo </span>tableKeysInfo <span style="COLOR: blue">in </span>tablesToBackup)<br/>
        {<br/>
            <span style="COLOR: #2b91af">CloudBlobContainer </span>container = blobClient.GetContainerReference(tableKeysInfo.TableName.ToLower());<br/>
            container.CreateIfNotExist();</p>
<p>            <span style="COLOR: blue">foreach </span>(PartitionKeyRange range <span style="COLOR: blue">in </span>tableKeysInfo.KeyRangeList)<br/>
            {<br/>
                BackupTableRange(tableClient, container, tableKeysInfo.TableName, range, backupId);<br/>
            }<br/>
        }<br/>
    }<br/>
    <span style="COLOR: blue">catch </span>(<span style="COLOR: #2b91af">Exception </span>e)<br/>
    {<br/>
        <span style="COLOR: green">// TODO: log exception for debugging purpose and then rethrow</p>
<p>        </span><span style="COLOR: blue">throw</span>;<br/>
    }<br/>
}</pre><a href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></a><br/>
<p>The BackupTableRange builds a query that will scan the assigned key range and then invoke BackupToContainer as shown below. We use the BackupEntity class to read the result. The BackupEntity stores an internal XElement called EntryElement that stores the raw OData XML for the entity that is received in the query response. To get hold of this raw data, we use the ReadingEntity event on the context as shown in the code. The ResolveType delegate is used to provide the type name that WCF Data Service client should use (See this forum <a href="http://social.msdn.microsoft.com/Forums/en-US/windowsazure/thread/d84ba34b-b0e0-4961-a167-bbe7618beb83" mce_href="http://social.msdn.microsoft.com/Forums/en-US/windowsazure/thread/d84ba34b-b0e0-4961-a167-bbe7618beb83">post</a> for details). </p><pre class="code"><span style="COLOR: gray">/// &lt;summary&gt;<br/>
/// </span><span style="COLOR: green">Create a query that will scan the assigned range and save it to a blob in the given container<br/>
</span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
/// &lt;param name="tableClient"&gt;&lt;/param&gt;<br/>
/// &lt;param name="container"&gt;&lt;/param&gt;<br/>
/// &lt;param name="tableName"&gt;&lt;/param&gt;<br/>
/// &lt;param name="range"&gt;&lt;/param&gt;<br/>
/// &lt;param name="backupId"&gt;&lt;/param&gt;<br/>
</span><span style="COLOR: blue">private static void </span>BackupTableRange(<br/>
<span style="COLOR: #2b91af">CloudTableClient </span>tableClient,<br/>
<span style="COLOR: #2b91af">CloudBlobContainer </span>container,<br/>
<span style="COLOR: blue">string </span>tableName,<br/>
PartitionKeyRange range,<br/>
<span style="COLOR: blue">string </span>backupId)<br/>
{<br/>
        <span style="COLOR: #2b91af">TableServiceContext </span>context = tableClient.GetDataServiceContext();<br/>
        context.MergeOption = MergeOption.NoTracking;<br/>
        context.ResolveType = TableBackup.ResolveType;<br/>
        context.ReadingEntity += <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">EventHandler</span>&lt;ReadingWritingEntityEventArgs&gt;(TableBackup.OnReadingEntity);<br/>
        context.RetryPolicy = <span style="COLOR: #2b91af">RetryPolicies</span>.RetryExponential(5, <span style="COLOR: #2b91af">RetryPolicies</span>.DefaultClientBackoff);</p>
<p>        <span style="COLOR: blue">var </span>query = <span style="COLOR: blue">from </span>entity <span style="COLOR: blue">in </span>context.CreateQuery&lt;<span style="COLOR: #2b91af">BackupEntity</span>&gt;(tableName) <span style="COLOR: blue">select </span>entity;<br/>
        <span style="COLOR: blue">if </span>(range.Min != <span style="COLOR: blue">null</span>)<br/>
        {<br/>
            query = query.Where(entity =&gt; entity.PartitionKey.CompareTo(range.Min) &gt;= 0);<br/>
        }</p>
<p>        <span style="COLOR: blue">if </span>(range.Max != <span style="COLOR: blue">null</span>)<br/>
        {<br/>
            query = query.Where(entity =&gt; entity.PartitionKey.CompareTo(range.Max) &lt; 0);<br/>
        }</p>
<p>        <span style="COLOR: #2b91af">CloudTableQuery</span>&lt;<span style="COLOR: #2b91af">BackupEntity</span>&gt; cloudQuery = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">CloudTableQuery</span>&lt;<span style="COLOR: #2b91af">BackupEntity</span>&gt;((DataServiceQuery&lt;<span style="COLOR: #2b91af">BackupEntity</span>&gt;)query);</p>
<p>        BackupToContainer(container, cloudQuery, backupId, range);<br/>
}</p>
<p><span style="COLOR: gray">/// &lt;summary&gt;<br/>
/// </span><span style="COLOR: green">Entities used for backup/restore<br/>
</span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
</span>[DataServiceKey(<span style="COLOR: #a31515">"PartitionKey"</span>, <span style="COLOR: #a31515">"RowKey"</span>)]<br/>
<span style="COLOR: blue">public class </span><span style="COLOR: #2b91af">BackupEntity<br/>
</span>{<br/>
    <span style="COLOR: blue">public string </span>PartitionKey { <span style="COLOR: blue">get</span>; <span style="COLOR: blue">set</span>; }</p>
<p>    <span style="COLOR: blue">public string </span>RowKey { <span style="COLOR: blue">get</span>; <span style="COLOR: blue">set</span>; }</p>
<p>    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">Used during restore to store the entry element.<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    </span><span style="COLOR: blue">internal </span>XElement EntryElement { <span style="COLOR: blue">get</span>; <span style="COLOR: blue">set</span>; }<br/>
}</p>
<p><span style="COLOR: blue">static void </span>OnReadingEntity(<span style="COLOR: blue">object </span>sender, ReadingWritingEntityEventArgs args)<br/>
{<br/>
     <span style="COLOR: #2b91af">BackupEntity </span>entity = args.Entity <span style="COLOR: blue">as </span><span style="COLOR: #2b91af">BackupEntity</span>;<br/>
     entity.EntryElement = args.Data;<br/>
}</p>
<p><span style="COLOR: blue">static </span><span style="COLOR: #2b91af">Type </span>ResolveType(<span style="COLOR: blue">string </span>entityName)<br/>
{<br/>
        <span style="COLOR: blue">return typeof</span>(<span style="COLOR: #2b91af">BackupEntity</span>);<br/>
}</pre><a href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></a><br/>
<p>The BackupToContainer creates a Block Blob to save the result set. Each block in the blob contains a collection of batches. Each batch contains a collection of entities that can be part of a single Entity Group Transaction i.e. batch command. This means all of the entities in the same batch must have the same PartitionKey value. The entity is stored as an entry element which is the raw format that the OData protocol uses to send the entity over the wire. The xml in a blob will look like the following with each Block portion being in a single block. </p><pre class="code"><font color="#ff0000">&lt;?xml version=<span style="COLOR: #a31515">"1.0" </span>encoding=<span style="COLOR: #a31515">"utf-8"</span>?&gt;<br/>
&lt;Block&gt;<br/>
    &lt;Batch&gt;<br/>
        &lt;entry&gt;...&lt;/entry&gt;<br/>
        &lt;entry&gt;...&lt;/entry&gt;<br/>
        &lt;entry&gt;...&lt;/entry&gt;<br/>
    &lt;/Batch&gt;<br/>
    &lt;Batch&gt;<br/>
        &lt;entry&gt;...&lt;/entry&gt;<br/>
        &lt;entry&gt;...&lt;/entry&gt;<br/>
    &lt;/Batch&gt;<br/>
&lt;/Block&gt;</font><br/>
<font color="#0000ff">&lt;?xml version=<span style="COLOR: #a31515">"1.0" </span>encoding=<span style="COLOR: #a31515">"utf-8"</span>?&gt;<br/>
&lt;Block&gt;<br/>
    &lt;Batch&gt;<br/>
        &lt;entry&gt;...&lt;/entry&gt;<br/>
        &lt;entry&gt;...&lt;/entry&gt;<br/>
    &lt;/Batch&gt;<br/>
    &lt;Batch&gt;<br/>
        &lt;entry&gt;...&lt;/entry&gt;<br/>
        &lt;entry&gt;...&lt;/entry&gt;<br/>
    &lt;/Batch&gt;<br/>
&lt;/Block&gt;</font></pre><a href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></a><br/>
<p>Since each block is a well formed xml, it allows us to read one block at a time and execute the group of transactions in them during the restore process.</p><br/>
<p>To build this structure, we will need some classes to be defined that we will go over first.</p><br/>
<ul><br/>
<li><b>State class</b> – maintains a global state that is used while iterating through the entities in the query. It keeps track of the size that has been serialized into a memory stream. It also controls the entity iteration over the query. </li><br/>
<li><b>Batch class</b> – is a group of entities that can be part of a single batch transaction. It reads an entity from the query and as long as the number of entities is less than 100, the entities have the same partition key, and we do not exceed the size limit, we keep returning entities to batch up. </li><br/>
<li><b>Block class</b> – is a single block element that stores the group of batch commands. A block has a size limit to maintain. A block can be at most 4MB but we limit it to less than that because when the batch request is sent, more xml tags for the request are added as required by the OData protocol and there is a per entity overhead to consider. </li><br/>
<li><b>Blob class</b> – is a list of blocks that will be stored in a single blob. We set an arbitrary limit of 20 blocks per backup blob to allow easy parallelization of the backup restore at the blob level. This can easily be changed to a larger value, but must be less than 50,000 blocks, since that is the limit per Block Blob set by the storage system. The name of the blob will be &lt;Backup Id&gt;/&lt;guid&gt;_&lt;Min range&gt;_&lt;Max range&gt;and will be placed in a container which has the same name as the table but lower cased. </li><br/>
<li>So the complete Uri will be: &lt;Container name&gt;/&lt;Backup Id&gt;/&lt;guid&gt;_&lt;Min range&gt;_&lt;Max range&gt;<br/>
<ul><br/>
<li><b>Container name</b> – is the lower cased name of the table </li><br/>
<li><b>Backup Id</b> – is the unique id formed from the timestamp when the backup started. The format used is: “yy-MM-dd-HH-mm-ss” </li><br/>
<li><b>Min range</b> – the min key used for the query. “null” if the min key is unbounded in the query range. </li><br/>
<li><b>Max range</b> – the max key used for the query. “null” if the max key is unbounded in the query range. </li></ul></li></ul><br/>
<p>Given the above classes, serializing into a blob is simple. As long as there is an entity we have not processed in the iterator, we will group entities into batches and batches into blocks. Each block class will be written to an Azure Blob Block and we will reset the MemoryStream since the next entity will be written to a new batch that belongs to a new block. When we hit the limit for blocks in a blob, we will invoke PutBlockList with all the block ids written and create a new blob for future blocks. The BackupToBlock stores the data we have written into memory stream to a block only if we have seen at least one entity. </p><pre class="code"><span style="COLOR: blue">static void </span>BackupToContainer(<span style="COLOR: #2b91af">CloudBlobContainer </span>containerToSave, <span style="COLOR: #2b91af">CloudTableQuery</span>&lt;<span style="COLOR: #2b91af">BackupEntity</span>&gt; query,<br/>
            <span style="COLOR: blue">string </span>backupId, PartitionKeyRange range)<br/>
{<br/>
        <span style="COLOR: green">// A block can be at most 4 MB in Azure Storage. Though we will be using much  less<br/>
        // we will allocate 4MB for the edge case where an entity may be 1MB<br/>
        </span>MemoryStream stream = <span style="COLOR: blue">new </span>MemoryStream(4 * 1024 * 1024);<br/>
        <span style="COLOR: #2b91af">State </span>state = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">State</span>(query, stream);</p>
<p>        <span style="COLOR: #2b91af">BlobRequestOptions </span>requestOptions = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">BlobRequestOptions</span>()<br/>
        {<br/>
            RetryPolicy = <span style="COLOR: #2b91af">RetryPolicies</span>.RetryExponential(5, <span style="COLOR: #2b91af">RetryPolicies</span>.DefaultClientBackoff)<br/>
        };</p>
<p>        <span style="COLOR: blue">while </span>(!state.HasCompleted)<br/>
        {<br/>
            <span style="COLOR: green">// Store the resultset to a blob in the container. We will use a naming scheme but the scheme does not<br/>
           //  have any conseuqences on the strategy itself<br/>
            </span><span style="COLOR: blue">string </span>backupFileName = <span style="COLOR: blue">string</span>.Format(<span style="COLOR: #a31515">"{0}/{1}_{2}_{3}.xml"</span>,<br/>
                backupId,<br/>
                <span style="COLOR: #2b91af">Guid</span>.NewGuid(),<br/>
                range.Min == <span style="COLOR: blue">null </span>? <span style="COLOR: #a31515">"null" </span>: range.Min.GetHashCode().ToString(),<br/>
                range.Max == <span style="COLOR: blue">null </span>? <span style="COLOR: #a31515">"null" </span>: range.Max.GetHashCode().ToString());<br/>
            <span style="COLOR: #2b91af">CloudBlockBlob </span>backupBlob = containerToSave.GetBlockBlobReference(backupFileName);</p>
<p>            <span style="COLOR: #2b91af">Blob </span>blob = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">Blob</span>(state);</p>
<p>            <span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: blue">string</span>&gt; blockIdList = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">List</span>&lt;<span style="COLOR: blue">string</span>&gt;();</p>
<p>            <span style="COLOR: blue">foreach </span>(<span style="COLOR: #2b91af">Block </span>block <span style="COLOR: blue">in </span>blob.Blocks)<br/>
            {<br/>
                <span style="COLOR: blue">string </span>blockId = BackupBlock(stream, requestOptions, backupBlob, block);<br/>
                <span style="COLOR: blue">if </span>(!<span style="COLOR: blue">string</span>.IsNullOrEmpty(blockId))<br/>
                {<br/>
                    blockIdList.Add(blockId);<br/>
                }<br/>
            }</p>
<p>            <span style="COLOR: blue">if </span>(blockIdList.Count &gt; 0)<br/>
            {<br/>
                <span style="COLOR: green">// commit block list<br/>
                </span>backupBlob.PutBlockList(blockIdList, requestOptions);<br/>
            }<br/>
        }<br/>
}</p>
<p><span style="COLOR: blue">private static string </span>BackupBlock(MemoryStream stream, <span style="COLOR: #2b91af">BlobRequestOptions </span>requestOptions, <span style="COLOR: #2b91af">CloudBlockBlob </span>backupBlob, <span style="COLOR: #2b91af">Block </span>block)<br/>
{<br/>
        <span style="COLOR: blue">int </span>entityCount = 0;</p>
<p>        <span style="COLOR: green">// reset the memory stream as we begin a new block<br/>
        </span>stream.Seek(0, SeekOrigin.Begin);<br/>
        stream.SetLength(0);<br/>
        XmlWriter writer = XmlWriter.Create(stream);</p>
<p>        writer.WriteStartElement(<span style="COLOR: #a31515">"Block"</span>);<br/>
        <span style="COLOR: blue">foreach </span>(<span style="COLOR: #2b91af">Batch </span>batch <span style="COLOR: blue">in </span>block.Batches)<br/>
        {<br/>
            <span style="COLOR: green">// write begin batch statement<br/>
            </span>writer.WriteStartElement(<span style="COLOR: #a31515">"Batch"</span>);<br/>
            <span style="COLOR: blue">foreach </span>(<span style="COLOR: #2b91af">BackupEntity </span>entity <span style="COLOR: blue">in </span>batch.Entities)<br/>
            {<br/>
                entityCount++;<br/>
                entity.EntryElement.WriteTo(writer);<br/>
                            }<br/>
            writer.WriteEndElement();</p>
<p>        }<br/>
        writer.WriteEndElement();<br/>
        writer.Close();<br/>
        stream.SetLength(stream.Position);<br/>
        stream.Seek(0, SeekOrigin.Begin);</p>
<p>        <span style="COLOR: green">// if we have written &gt; 0 entities, let us store to a block. Else we can reject this block<br/>
        </span><span style="COLOR: blue">if </span>(entityCount &gt; 0)<br/>
        {<br/>
            backupBlob.PutBlock(block.BlockId, stream, <span style="COLOR: blue">null</span>, requestOptions);<br/>
            <span style="COLOR: blue">return </span>block.BlockId;<br/>
        }</p>
<p>        <span style="COLOR: blue">return null</span>;<br/>
}</p>
<p><span style="COLOR: gray">/// &lt;summary&gt;<br/>
/// </span><span style="COLOR: green">The class that maintains the global state for the iteration<br/>
</span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
</span><span style="COLOR: blue">internal class </span><span style="COLOR: #2b91af">State<br/>
</span>{<br/>
    <span style="COLOR: blue">protected </span>MemoryStream stream;<br/>
    <span style="COLOR: #2b91af">IEnumerator</span>&lt;<span style="COLOR: #2b91af">BackupEntity</span>&gt; queryIterator;</p>
<p>    <span style="COLOR: blue">internal </span>State(<span style="COLOR: #2b91af">CloudTableQuery</span>&lt;<span style="COLOR: #2b91af">BackupEntity</span>&gt; query, MemoryStream stream)<br/>
    {<br/>
        <span style="COLOR: blue">this</span>.queryIterator = query.GetEnumerator();<br/>
        <span style="COLOR: blue">this</span>.stream = stream;<br/>
    }</p>
<p>    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">This entity is the one we may have retrieved but it does not belong to the batch<br/>
    </span><span style="COLOR: gray">/// </span><span style="COLOR: green">So we store it here so that it can be returned on the next iteration<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    </span><span style="COLOR: blue">internal </span><span style="COLOR: #2b91af">BackupEntity </span>LookAheadEntity { <span style="COLOR: blue">private get</span>; <span style="COLOR: blue">set</span>; }</p>
<p>    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">We have completed if look ahead entity is null and iterator is completed too.<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    </span><span style="COLOR: blue">internal bool </span>HasCompleted<br/>
    {<br/>
        <span style="COLOR: blue">get<br/>
        </span>{<br/>
            <span style="COLOR: blue">return this</span>.queryIterator == <span style="COLOR: blue">null </span>&amp;&amp; <span style="COLOR: blue">this</span>.LookAheadEntity == <span style="COLOR: blue">null</span>;<br/>
        }<br/>
    }</p>
<p>    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">Get the amount of data we have saved in the entity<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    </span><span style="COLOR: blue">internal long </span>CurrentBlockSize<br/>
    {<br/>
        <span style="COLOR: blue">get<br/>
        </span>{<br/>
            stream.Flush();<br/>
            <span style="COLOR: blue">return </span>stream.Position;<br/>
        }<br/>
    }</p>
<p>    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">Return the next entity - which can be either the<br/>
    </span><span style="COLOR: gray">/// </span><span style="COLOR: green">look ahead entity or a new one from the iterator.<br/>
    </span><span style="COLOR: gray">/// </span><span style="COLOR: green">We return null if there are no more entities<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    /// &lt;returns&gt;&lt;/returns&gt;<br/>
    </span><span style="COLOR: blue">internal </span><span style="COLOR: #2b91af">BackupEntity </span>GetNextEntity()<br/>
    {<br/>
        <span style="COLOR: #2b91af">BackupEntity </span>entityToReturn = <span style="COLOR: blue">null</span>;<br/>
        <span style="COLOR: blue">if </span>(<span style="COLOR: blue">this</span>.LookAheadEntity != <span style="COLOR: blue">null</span>)<br/>
        {<br/>
            entityToReturn = <span style="COLOR: blue">this</span>.LookAheadEntity;<br/>
            <span style="COLOR: blue">this</span>.LookAheadEntity = <span style="COLOR: blue">null</span>;<br/>
        }<br/>
        <span style="COLOR: blue">else if </span>(<span style="COLOR: blue">this</span>.queryIterator != <span style="COLOR: blue">null</span>)<br/>
        {<br/>
            <span style="COLOR: blue">if </span>(<span style="COLOR: blue">this</span>.queryIterator.MoveNext())<br/>
            {<br/>
                entityToReturn = <span style="COLOR: blue">this</span>.queryIterator.Current;<br/>
            }<br/>
            <span style="COLOR: blue">else<br/>
            </span>{<br/>
                <span style="COLOR: blue">this</span>.queryIterator = <span style="COLOR: blue">null</span>;<br/>
            }<br/>
        }</p>
<p>        <span style="COLOR: blue">return </span>entityToReturn;<br/>
    }<br/>
}</p>
<p><span style="COLOR: gray">/// &lt;summary&gt;<br/>
/// </span><span style="COLOR: green">Represents a collection of entities in a single batch<br/>
</span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
</span><span style="COLOR: blue">internal class </span><span style="COLOR: #2b91af">Batch<br/>
</span>{<br/>
    <span style="COLOR: blue">static int </span>MaxEntityCount = 100;<br/>
    <span style="COLOR: green">// Save at most 3.5MB in a batch so that we have enough room for<br/>
    // the xml tags that WCF Data Services adds in the OData protocol<br/>
    </span><span style="COLOR: blue">static int </span>MaxBatchSize = (<span style="COLOR: blue">int</span>)(3.5 * 1024 * 1024);</p>
<p>    <span style="COLOR: #2b91af">State </span>state;</p>
<p>    <span style="COLOR: blue">internal </span>Batch(<span style="COLOR: #2b91af">State </span>state)<br/>
    {<br/>
        <span style="COLOR: blue">this</span>.state = state;<br/>
    }</p>
<p>    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">Yield entities until we hit a condition that should terminate a batch.<br/>
    </span><span style="COLOR: gray">/// </span><span style="COLOR: green">The conditions to terminate on are:<br/>
    </span><span style="COLOR: gray">/// </span><span style="COLOR: green">1. 100 entities in a batch<br/>
    </span><span style="COLOR: gray">/// </span><span style="COLOR: green">2. 3.5MB of data<br/>
    </span><span style="COLOR: gray">/// </span><span style="COLOR: green">2. 3.8MB of block size<br/>
    </span><span style="COLOR: gray">/// </span><span style="COLOR: green">3. We see a new partition key<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    </span><span style="COLOR: blue">internal </span><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">BackupEntity</span>&gt; Entities<br/>
    {<br/>
        <span style="COLOR: blue">get<br/>
        </span>{<br/>
            <span style="COLOR: #2b91af">BackupEntity </span>entity;<br/>
            <span style="COLOR: blue">long </span>currentSize = <span style="COLOR: blue">this</span>.state.CurrentBlockSize;</p>
<p>            <span style="COLOR: blue">string </span>lastPartitionKeySeen = <span style="COLOR: blue">null</span>;<br/>
            <span style="COLOR: blue">int </span>entityCount = 0;</p>
<p>            <span style="COLOR: blue">while </span>((entity = state.GetNextEntity()) != <span style="COLOR: blue">null</span>)<br/>
            {<br/>
                <span style="COLOR: blue">if </span>(lastPartitionKeySeen == <span style="COLOR: blue">null</span>)<br/>
                {<br/>
                    lastPartitionKeySeen = entity.PartitionKey;<br/>
                }</p>
<p>                <span style="COLOR: blue">int </span>approxEntitySize = entity.EntryElement.ToString().Length * 2;<br/>
                <span style="COLOR: blue">long </span>batchSize = <span style="COLOR: blue">this</span>.state.CurrentBlockSize - currentSize;<br/>
                <span style="COLOR: blue">if </span>(entityCount &gt;= <span style="COLOR: #2b91af">Batch</span>.MaxEntityCount<br/>
                    || !<span style="COLOR: blue">string</span>.Equals(entity.PartitionKey, lastPartitionKeySeen)<br/>
                    || batchSize + approxEntitySize &gt; <span style="COLOR: #2b91af">Batch</span>.MaxBatchSize<br/>
                    || <span style="COLOR: blue">this</span>.state.CurrentBlockSize + approxEntitySize &gt; <span style="COLOR: #2b91af">Block</span>.MaxBlockSize)<br/>
                {<br/>
                    <span style="COLOR: green">// set this current entity as the look ahead since it needs to be part of the next batch<br/>
                    </span>state.LookAheadEntity = entity;<br/>
                    <span style="COLOR: blue">yield break</span>;<br/>
                }</p>
<p>                entityCount++;<br/>
                <span style="COLOR: blue">yield return </span>entity;<br/>
            }<br/>
        }<br/>
    }<br/>
}</p>
<p><span style="COLOR: gray">/// &lt;summary&gt;<br/>
/// </span><span style="COLOR: green">Represents all batches in a block<br/>
</span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
</span><span style="COLOR: blue">internal class </span><span style="COLOR: #2b91af">Block<br/>
</span>{<br/>
    <span style="COLOR: green">// Though a block can be of 4MB we will stop before to allow buffer<br/>
    </span><span style="COLOR: blue">static int </span>MaxBlockSize = (<span style="COLOR: blue">int</span>)(3.8 * 1024 * 1024);</p>
<p>    <span style="COLOR: #2b91af">State </span>state;</p>
<p>    <span style="COLOR: blue">internal string </span>BlockId { <span style="COLOR: blue">get</span>; <span style="COLOR: blue">private set</span>; }</p>
<p>    <span style="COLOR: blue">internal </span>Block(<span style="COLOR: #2b91af">State </span>state)<br/>
    {<br/>
        <span style="COLOR: blue">this</span>.state = state;<br/>
        <span style="COLOR: blue">this</span>.BlockId = <span style="COLOR: #2b91af">Convert</span>.ToBase64String(<span style="COLOR: #2b91af">Guid</span>.NewGuid().ToByteArray());<br/>
    }</p>
<p>    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">The list of batches in the block.<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    </span><span style="COLOR: blue">internal </span><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Batch</span>&gt; Batches<br/>
    {<br/>
        <span style="COLOR: blue">get<br/>
        </span>{<br/>
            <span style="COLOR: blue">while </span>(!state.HasCompleted &amp;&amp; state.CurrentBlockSize &lt; <span style="COLOR: #2b91af">Block</span>.MaxBlockSize)<br/>
            {<br/>
                <span style="COLOR: blue">yield return new </span><span style="COLOR: #2b91af">Batch</span>(state);<br/>
            }<br/>
        }<br/>
    }<br/>
}</p>
<p><span style="COLOR: gray">/// &lt;summary&gt;<br/>
/// </span><span style="COLOR: green">Represents all blocks in a blob<br/>
</span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
</span><span style="COLOR: blue">internal class </span><span style="COLOR: #2b91af">Blob<br/>
</span>{<br/>
    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">We will allow storing at most 20 blocks in a blob<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    </span><span style="COLOR: blue">static int </span>MaxBlocksInBlobs = 20;</p>
<p>    <span style="COLOR: #2b91af">State </span>state;<br/>
    <span style="COLOR: blue">internal </span><span style="COLOR: #2b91af">CloudBlob </span>blob { <span style="COLOR: blue">get</span>; <span style="COLOR: blue">private set</span>; }</p>
<p>    <span style="COLOR: blue">internal </span>Blob(<span style="COLOR: #2b91af">State </span>state)<br/>
    {<br/>
        <span style="COLOR: blue">this</span>.state = state;<br/>
    }</p>
<p>    <span style="COLOR: gray">/// &lt;summary&gt;<br/>
    /// </span><span style="COLOR: green">The blocks that form the blob<br/>
    </span><span style="COLOR: gray">/// &lt;/summary&gt;<br/>
    </span><span style="COLOR: blue">internal </span><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">Block</span>&gt; Blocks<br/>
    {<br/>
        <span style="COLOR: blue">get<br/>
        </span>{<br/>
            <span style="COLOR: blue">int </span>blockCount = 0;</p>
<p>            <span style="COLOR: blue">while </span>(!state.HasCompleted &amp;&amp; blockCount &lt; <span style="COLOR: #2b91af">Blob</span>.MaxBlocksInBlobs)<br/>
            {<br/>
                blockCount++;<br/>
                <span style="COLOR: blue">yield return new </span><span style="COLOR: #2b91af">Block</span>(state);<br/>
            }<br/>
        }<br/>
    }<br/>
}</pre><a href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></a><br/>
<p>This allows us to store a single table into multiple blobs and allows restore to be parallelized across these blobs. </p><br/>
<h4>Table Restore</h4><br/>
<p>To restore tables from blobs, we can get the list of blobs in the container “table name” and then for each blob, we retrieve the list of blocks. For each block in the blob, we load the xml and retrieve the entry elements and create a BackupEntity instance for each entry we add to the context. Once we have added all entities in a batch element, we can call SaveChanges with Batch option to execute the transaction. The restore process assumes that it is a new table with no existing entities - so any “conflict” errors during the adding process is ignored.</p><pre class="code"><span style="COLOR: #2b91af">CloudBlobContainer </span>container = blobClient.GetContainerReference(tableName.ToLower());<br/>
<span style="COLOR: #2b91af">CloudBlobDirectory </span>dir = container.GetDirectoryReference(backupIdToRestore);</p>
<p><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">IListBlobItem</span>&gt; blobs = dir.ListBlobs();<br/>
<span style="COLOR: blue">foreach </span>(<span style="COLOR: #2b91af">IListBlobItem </span>blob <span style="COLOR: blue">in </span>blobs)<br/>
{<br/>
      <span style="COLOR: #2b91af">CloudBlockBlob </span>blockBlob = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">CloudBlockBlob</span>(blob.Uri.AbsoluteUri);<br/>
      blockBlob = container.GetBlockBlobReference(blob.Uri.AbsoluteUri);<br/>
      TableRestore.RestoreTo(tableClient, blockBlob, tableToRestoreTo);<br/>
}</pre><a href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></a><br/>
<p>The RestoreTo method gets the block list and for each blob, it then downloads the data using range gets for each block. It then retrieves the list of batch elements for each block, and for each batch element it invokes ExecuteBatch method.</p><pre class="code"><span style="COLOR: blue">static void </span>RestoreTo(<span style="COLOR: #2b91af">CloudTableClient </span>tableClient, <span style="COLOR: #2b91af">CloudBlockBlob </span>blob, <span style="COLOR: blue">string </span>tableName)<br/>
{<br/>
        tableClient.CreateTableIfNotExist(tableName);</p>
<p>        <span style="COLOR: #2b91af">BlobRequestOptions </span>options = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">BlobRequestOptions</span>()<br/>
            {<br/>
                RetryPolicy = <span style="COLOR: #2b91af">RetryPolicies</span>.RetryExponential(5, <span style="COLOR: #2b91af">RetryPolicies</span>.DefaultClientBackoff)<br/>
            };</p>
<p>        <span style="COLOR: green">// get all blocks and for each block read it separately as it is an xml doc by itself<br/>
        </span><span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">ListBlockItem</span>&gt; blocks = (<span style="COLOR: #2b91af">IEnumerable</span>&lt;<span style="COLOR: #2b91af">ListBlockItem</span>&gt;)blob.DownloadBlockList(<span style="COLOR: #2b91af">BlockListingFilter</span>.Committed, options);</p>
<p>        <span style="COLOR: blue">long </span>currentOffset = 0;<br/>
        <span style="COLOR: blue">foreach </span>(<span style="COLOR: #2b91af">ListBlockItem </span>block <span style="COLOR: blue">in </span>blocks)<br/>
        {<br/>
            <span style="COLOR: green">// read each block using the range<br/>
           </span><span style="COLOR: #2b91af">HttpWebRequest </span>request = BlobRequest.Get(blob.Uri, 120, <span style="COLOR: blue">null</span>, currentOffset, block.Size, <span style="COLOR: blue">null</span>);<br/>
            blob.ServiceClient.Credentials.SignRequest(request);</p>
<p>            XDocument doc = <span style="COLOR: blue">null</span>;</p>
<p>            <span style="COLOR: blue">using </span>(<span style="COLOR: #2b91af">HttpWebResponse </span>response = (<span style="COLOR: #2b91af">HttpWebResponse</span>)request.GetResponse())<br/>
            {<br/>
                <span style="COLOR: blue">using </span>(Stream stream = response.GetResponseStream())<br/>
                {<br/>
                    doc = XDocument.Load(<span style="COLOR: blue">new </span>XmlTextReader(stream));<br/>
                }<br/>
            }</p>
<p>            <span style="COLOR: #2b91af">IEnumerable</span>&lt;XElement&gt; batchNodes = doc.Element(<span style="COLOR: #a31515">"Batches"</span>).Elements(<span style="COLOR: #a31515">"Batch"</span>);<br/>
            <span style="COLOR: blue">foreach</span>(XElement batchNode <span style="COLOR: blue">in </span>batchNodes)<br/>
            {<br/>
                ExecuteBatch(tableClient, tableName, batchNode);<br/>
            }</p>
<p>            currentOffset += block.Size;<br/>
        }</pre><a href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></a><br/>
<p>The ExecuteBatch method retrieves all entry elements in the batch and creates a BackupEntity instance and adds it the context. It sets the WritingEntity event to control the xml sent over the wire. WritingEntity is called after WCF Data Services forms the xml element, but before it is serialized over the wire. We use the WritingEntity event to replace the property element of what WCF Data Services has written with the property element that we have retrieved from the entry element saved in the blob.</p><pre class="code"><span style="COLOR: blue">static void </span>ExecuteBatch(<span style="COLOR: #2b91af">CloudTableClient </span>tableClient, <span style="COLOR: blue">string </span>tableName, XElement batchNode)<br/>
{<br/>
        <span style="COLOR: #2b91af">TableServiceContext </span>context = tableClient.GetDataServiceContext();<br/>
        context.WritingEntity += <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">EventHandler</span>&lt;ReadingWritingEntityEventArgs&gt;(OnWritingEntity);</p>
<p>        <span style="COLOR: green">// for each entry create a backup entity<br/>
        </span><span style="COLOR: #2b91af">IEnumerable</span>&lt;XElement&gt; entries = batchNode.Elements(AtomNamespace + <span style="COLOR: #a31515">"entry"</span>);<br/>
        <span style="COLOR: blue">foreach </span>(XElement entryNode <span style="COLOR: blue">in </span>entries)<br/>
        {<br/>
            XElement propertiesElem = entryNode.Elements(AtomNamespace + <span style="COLOR: #a31515">"content"</span>)<br/>
                                            .Elements(AstoriaMetadataNamespace + <span style="COLOR: #a31515">"properties"</span>)<br/>
                                            .FirstOrDefault();<br/>
            XElement pkElement = propertiesElem.Element(AstoriaDataNamespace + <span style="COLOR: #a31515">"PartitionKey"</span>);<br/>
            XElement rkElement = propertiesElem.Element(AstoriaDataNamespace + <span style="COLOR: #a31515">"RowKey"</span>);</p>
<p>            <span style="COLOR: #2b91af">BackupEntity </span>entity = <span style="COLOR: blue">new </span><span style="COLOR: #2b91af">BackupEntity</span>()<br/>
                {<br/>
                    PartitionKey = pkElement.Value,<br/>
                    RowKey = pkElement.Value,<br/>
                    EntryElement = entryNode<br/>
                };</p>
<p>            context.AddObject(tableName, entity);<br/>
        }</p>
<p>        context.BatchWithRetries(<span style="COLOR: #2b91af">TableExtensions</span>.RetryExponential());<br/>
}</p>
<p><span style="COLOR: blue">static void </span>OnWritingEntity(<span style="COLOR: blue">object </span>sender, ReadingWritingEntityEventArgs args)<br/>
{<br/>
        <span style="COLOR: #2b91af">BackupEntity </span>entity = args.Entity <span style="COLOR: blue">as </span><span style="COLOR: #2b91af">BackupEntity</span>;<br/>
        XElement content = args.Data.Element(AtomNamespace + <span style="COLOR: #a31515">"content"</span>);<br/>
        XElement propertiesElem = content.Element(AstoriaMetadataNamespace + <span style="COLOR: #a31515">"properties"</span>);</p>
<p>        propertiesElem.Remove();</p>
<p>        XElement propertiesElemToUse = entity.EntryElement.Elements(AtomNamespace + <span style="COLOR: #a31515">"content"</span>)<br/>
                                        .Elements(AstoriaMetadataNamespace + <span style="COLOR: #a31515">"properties"</span>)<br/>
                                        .FirstOrDefault();</p>
<p>        content.Add(propertiesElemToUse);<br/>
}</pre><a href="http://11011.net/software/vspaste" mce_href="http://11011.net/software/vspaste"></a><br/>
<p>The following are some improvements that can be applied to the above code are:</p><br/>
<ol><br/>
<li>Parallel processing of backup and restore for faster backup and restore.<br/>
<ul><br/>
<li>For backups, we can parallelize the query execution over the different ranges as well as over each table in the storage account. When we process the ranges in parallel, it can be good to randomly select the query ranges to better spread out the load of the backup over your tables in production. </li><br/>
<li>For restore we can parallelize by processing either different blobs or blocks in parallel and if we have multiple tables to restore, we can also parallelize across the different backup blob containers (representing different tables). </li></ul></li><br/>
<li>Rather than taking the list of keys as input from the user, we could remember the ranges we see from each run of the backup, and use them as input to guide the next backup to be performed. In doing this, each time we perform the backup, we would remember the key ranges we see, and use that information to form better backup ranges for the next backup to be performed in parallel. This can then be continuously improved based on how the dataset changes. In fact, with the above approach, one could list through the blobs from the prior backup and get the key ranges from the blob names. Then use this information to form the desired size of ranges when performing the next parallel backup. </li><br/>
<li>You may want to store a version or other metadata in the xml and with the blob so that it can be used during restore. </li><br/>
<li>You may also wish to store the blocks in a compressed format.</li></ol><br/>
<p>The code provided in this post is meant to be used as building blocks and not a full-fledged backup and restore tool. The idea was to go over some challenges and the options available to solve them. Please test the code if you intend to use it in your application. </p><br/>
<h4>Libraries that support backup</h4><br/>
<p>In this section we wanted to list known backup tools that we are aware of. We should point out that we have not verified the functionality claimed by these utilities and their listing does not imply an endorsement by Microsoft. Since these applications have not been verified, it is possible that they could exhibit undesirable behavior. </p><br/>
<p><br/>
<table border="1" cellspacing="0" cellpadding="0"><br/>
<tbody><br/>
<tr><br/>
<td valign="top" width="301"><br/>
<p><b>Windows Azure Storage Backup Utilities</b></p></td><br/>
<td valign="top" width="114"><br/>
<p><b>Blob</b></p></td><br/>
<td valign="top" width="114"><br/>
<p><b>Table</b></p></td><br/>
<td valign="top" width="109"><br/>
<p><b>Free</b></p></td></tr><br/>
<tr><br/>
<td valign="top" width="301"><br/>
<p><a href="http://tablestoragebackup.codeplex.com/" mce_href="http://tablestoragebackup.codeplex.com/">Table Storage Backup &amp; Restore for Windows Azure </a></p></td><br/>
<td valign="top" width="114"><br/>
<p>No</p></td><br/>
<td valign="top" width="114"><br/>
<p>Yes</p></td><br/>
<td valign="top" width="109"><br/>
<p>Yes</p></td></tr></tbody></table></p><br/>
<p>Also, please email us (using the link on the left of this site) if you have any ideas on the above code or if we have missed any library that provides data backup for storage accounts and we will add them to this list. </p><br/>
<p>Jai Haridas<a title="_GoBack" name="_GoBack"></a></p></p>
	</div><!-- .entry-content -->


	<footer class="entry-footer single">
					<div class="tags">
				<span>Tags </span>
				<span>
					<a href="https://blogs.msdn.microsoft.com/windowsazurestorage/tag/windows-azure-tables/" rel="tag">Windows Azure Tables</a>				</span>
			</div>
				<hr>
	</footer><!-- .entry-footer -->

</article><!-- #post-## -->

			
		</div><!-- #single-content -->

		
<div id="comments" class="comments-area">
	<div class="comments-title">
		Comments (3)	</div>

		<div id="respond" class="comment-respond">
		<h3 id="reply-title" class="comment-reply-title"> <small><a rel="nofollow" id="cancel-comment-reply-link" href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/03/protecting-your-tables-against-application-errors/#respond" style="display:none;">Cancel reply</a></small></h3><p class="must-log-in">You must be <a href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F03%2Fprotecting-your-tables-against-application-errors%2F">logged in</a> to post a comment.</p>	</div><!-- #respond -->
	
			<div class="navigation pagination clear-both">
					</div>

		<ol class="comment-list">
					<li class="comment even thread-even depth-1" id="comment-3182">
				<div id="div-comment-3182" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Anthony Super</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/03/protecting-your-tables-against-application-errors/#comment-3182">
			February 9, 2011 at 1:41 am</a>		</div>

		<p>Great article thanks. There are a few typos in the code that caught us out:</p>
<p> &#8211; ExecuteBatch function: RowKey = rkElement.Value, not RowKey = pkElement.Value</p>
<p> &#8211; RestoreTo function: IEnumerable&lt;XElement&gt; batchNodes = doc.Element(&quot;Block&quot;).Elements(&quot;Batch&quot;), not IEnumerable&lt;XElement&gt; batchNodes = doc.Element(&quot;Batches&quot;).Elements(&quot;Batch&quot;)</p>
<p>Cheers,</p>
<p>Anthony.</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F03%2Fprotecting-your-tables-against-application-errors%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment odd alt thread-odd thread-alt depth-1" id="comment-3172">
				<div id="div-comment-3172" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Mikel</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/03/protecting-your-tables-against-application-errors/#comment-3172">
			March 30, 2011 at 8:23 am</a>		</div>

		<p>Thanks for this article. I am fairly new to Azure, and there is something I would like to know. Could you give tips on how to integrate this backup solution (and also the earler solution for blobs) with an existing Asp.net/Silverlight application that is running within Azure? For instance, what role should the backup code run under, and what is the recommended way to trigger a backup within the application? We need to automate this as much as possible.</p>
<p>Thanks, Mikel</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F03%2Fprotecting-your-tables-against-application-errors%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		<li class="comment even thread-even depth-1" id="comment-3152">
				<div id="div-comment-3152" class="comment-body">
				<div class="comment-author vcard">
			<img alt="" src="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/3651e719491c63d4424134d66fe53db9?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo" height="56" width="56"/>			<cite class="fn">Jai Haridas (MSFT)</cite> <span class="says">says:</span>		</div>
		
		<div class="comment-meta commentmetadata"><a href="https://blogs.msdn.microsoft.com/windowsazurestorage/2010/05/03/protecting-your-tables-against-application-errors/#comment-3152">
			April 4, 2011 at 8:22 am</a>		</div>

		<p>@Mikel, I would run this in a worker role that gets the schedule for backup from a Azure Table. You can now modify the &quot;schedule&quot; row to change the frequency/time of backup. The table itself can be modified either via a ASP.NET/Silverlight app or using some app which allows you to modify rows in Azure Table. The worker role can get this schedule on startup and from there on, either poll every hour for a change or just sleep until it is time to perform the backup job (if applying the change to schedule is not very important). If you update the schedule via an app, you could trigger the change by updating the config for the worker role using service management APIs.</p>
<p>Thanks,</p>
<p>jai</p>

		<div class="reply"><a rel="nofollow" class="comment-reply-login" href="https://blogs.msdn.microsoft.com/windowsazurestorage/wp-login.php?redirect_to=https%3A%2F%2Fblogs.msdn.microsoft.com%2Fwindowsazurestorage%2F2010%2F05%2F03%2Fprotecting-your-tables-against-application-errors%2F">Log in to Reply</a></div>
				</div>
		</li><!-- #comment-## -->
		</ol><!-- .comment-list -->

		<div class="navigation pagination">
					</div>

	
	
</div><!-- .comments-area -->
	</div><!-- #primary -->