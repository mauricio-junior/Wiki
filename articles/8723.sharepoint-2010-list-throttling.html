---
layout: default
title: 'SharePoint 2010&#58; List Throttling - TechNet Articles - United States (English) - TechNet Wiki'
weight: 3
---

<div class="post-content user-defined-markup">

If you need to pull huge amounts of data from a list or several lists, you&#39;ll face
<a>list throttling limits</a>. This Wiki pages discusses best practice for dealing with those limits.<br />
<br />
The short term solution is to increase the throttling limits. Once you revert to this strategy, you&#39;ll soon find that every developer wants to lift the limits and server performance is in jeopardy. The throttling settings are there for a reason. Instead, try
 to follow the following best practices:
<ul>
<li>Organize your content or retrieval mechanism so that you don&#39;t need get more than the default threshold in one go.
</li><li>Use an advanced caching solution (such iji-r2"></div><div class="r3 fiji-r3"></div><div class="r4 fiji-r4"></div></div><div class="content-fragment-content">

<div class="full-post-header"></div>
<div class="full-post">
    <h1 class="post-name">SharePoint 2010: List Throttling</h1>
    

    <div class="post-content user-defined-markup">

If you need to pull huge amounts of data from a list or several lists, you&#39;ll face
<a>list throttling limits</a>. This Wiki pages discusses best practice for dealing with those limits.<br />
<br />
The short term solution is to increase the throttling limits. Once you revert to this strategy, you&#39;ll soon find that every developer wants to lift the limits and server performance is in jeopardy. The throttling settings are there for a reason. Instead, try
 to follow the following best practices:
<ul>
<li>Organize your content or retrieval mechanism so that you don&#39;t need get moras Windows Server AppFabric Caching) so that the query with all the list items doesn&#39;t need to run repeatedly.
</li><li>Use the search API instead, it has a minimal impact on performance (which can be optimized by using dedicated query servers) and is blazingly fast when it comes to returning results (be aware of the fact that it takes some time before the latest incremental
 index has run). </li><li>
<p>Make sure you are creating an optimized caml query to avoid threshold limits. This can be done by using indexed fields in your where clauses. Another possible optimization is to order or sort by an indexed field. You can force this by always sorting by the
 ID field using the following: </p>
<pre class="prettyprint"><span class="tag">&lt;OrderBy</span><span class="pln"> </span><span class="atn">Override</span><span class="pun">=</span><span class="atv">&#39;TRUE&#39;</span><span class="tag">&gt;&lt;FieldRef</span><span class="pln"> </span><span class="atn">Name</span><span class="pun">=</span><span class="atv">&#39;ID&#39;</span><span class="pln"> </span><span class="tag">/&gt;&lt;/OrderBy&gt;</span></pre>
</li><li>
<pre class="prettyprint"><span style="font-family:&#39;segoe ui&#39;;">You can also query in batches to avoid the limit. The PowerShell example in the link below uses a row limit of 2000 and the ListItemCollectionPosition: </span><a href="http://blogs.msdn.com/b/kaevans/archive/2012/02/13/iterating-large-sharepoint-lists-with-powershell.aspx"><span>http://blogs.msdn.com/b/kaevans/archive/2012/02/13/iterating-large-sharepoint-lists-with-powershell.aspx</span></a></pre>
</li></ul>
<pre class="prettyprint"><span style="font-family:&#39;segoe ui&#39;;">Inspired by forum discussion: <a href="http://social.technet.microsoft.com/Forums/en-US/sharepoint2010programming/thread/18802ebb-d9b6-44ad-a58b-e7c4810502fd">http://social.technet.microsoft.com/Forums/en-US/sharepoint2010programming/thread/18802ebb-d9b6-44ad-a58b-e7c4810502fd</a></span></pre>
<p>&nbsp;</p>
<ul>
</ul>

</div>
    
    
