---
layout: default
title: 'Software Design Principles - TechNet Articles - United States (English) - TechNet Wiki'
weight: 3
---

<div class="post-content user-defined-markup">

<div class="table-of-contents"><h2 class="title">Table of Contents</h2><div class="hierarchy-list-header"> </div><ul class="hierarchy-list"><li class="hierarchy-item"><a href="#Introduction">Introduction</a></li><li class="hierarchy-item"><a href="#The_important_characteristics_of_a_bad_design">Some characteristics of bad design</a></li><li class="hierarchy-item"><a href="#SOLID_Principles">SOLID Principles</a></li><li class="hierarchy-item"><a href="#In_addition_to_that_there_are_also_two_more_types_of_design_principles">Some other Principles</a></li><li class="hierarchy-item"><a href="#Miscellaneous_principles_which_are_worth_mentioning">Miscellaneous principles which are worth mentioning</a></li><li class="hierarchy-item"><a href="#See_Also">See Also</a></li></ul><div class="hierarchy-list-footer"> </div></div><br />
<br />
<h1><a name="Introduction"></a>Introduction</h1>
<br />
Software design principles are a set of guidelines that helps us to avoid the bad design of a solution. The software designs helps to make a software well designed, well read and best maintainable.&nbsp;<br />
<br />
The design principles are associated to Robert Martin who gathered all the design principles in his book &quot;<a href="http://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445" title="Principles, Patterns and Practices">Agile Software
 Development: Principles, patterns and practices</a>&quot;. <br />
<br />
<br />
<h1><a name="The_important_characteristics_of_a_bad_design"></a>Some characteristics of bad design</h1>
<br />
1. <strong>Rigidity</strong> &nbsp;- It implies that it is very hard to change anything in the code as every change affects too many other parts of the system. In the beginning of the simple change, it might seem that it might take a small time to change the logic,
 but with a rigid software model, the cascading changes on dependent modules takes engineers a hell lot of time that grows subsequently giving lot of grief to the developers. &nbsp;This is the type of development where manager fears to make any changes to the project.&nbsp;<br />
<br />
2. <strong>Fragility </strong>- It implies, making a change is too risky. When some changes are made, it makes other part of the system break. &nbsp;Often the breakage occurs in areas where there is no conceptual relationship with the area that has been changed.
 As fragility becomes worse over time, managers decide not to make any changes to the project and declare the project as unmaintainable.&nbsp;<br />
<br />
3. <strong>Immobility</strong> - It makes an application hard to mobile. That means, when building another application, it is very hard to reuse the same code in another application because it cannot be disentangled from the current application that easy. There
 could be also an element of risk involved while separating the desirable part of the software.<br />
<br />
4. <strong>Viscosity</strong> : Viscosity in an application comes in two ways. One &nbsp;is viscosity in design and viscosity in environment. &nbsp;Viscosity in design comes when a developer finds more than one way to make changes to the application and the way to face
 the change is harder to preserve the design. In other words, say a developer need a certain change in the application and he finds the hack to the application which can fix the problem is much easier than that of the one which preserve the design of the application
 in which it is build in, is said to viscous. &nbsp;Viscosity in environment is when the environment is not suitable in preserving the existing design of the application. For instance, say certain changes in files makes it pretty long time to compile etc.&nbsp;<br />
<br />
These four symptoms are signs of poor architecture. To avoid such symptoms in an application, it is recommended to employ certain design principles.&nbsp;<br />
<br />
<h1><a name="SOLID_Principles"></a>SOLID Principles</h1>
<br />
SOLID principles are set of rules first introduced by Michael Feathers for the &quot;First five principles&quot; which later identified by Robert C Martin in early 2000s. &nbsp;These stands out as the acronym for the five basic principles of Object oriented programming and
 design. The principles ensures that when it is correctly maintained over time, the programmer have to face lesser amount of problems while maintaining the application and the program itself will remain capable of extension. The Solid principles intend to remove
 code smells causing the programmer to refactor their code and make it well maintainable and extendable. The SOLID principles are mostly applied in Test Driven development and the overall strategy is adaptive programming.&nbsp;<br />
<br />
The Acronym SOLID is taken from the first letter of these five principles.&nbsp;<br />
<br />
1. <a href="http://social.technet.microsoft.com/wiki/contents/articles/18061.single-responsibility-principle.aspx">
Single Responsibility Principle</a><br />
2. <a href="http://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx">
Open Close Principle</a><br />
3. <a href="http://social.technet.microsoft.com/wiki/contents/articles/18063.liskov-substitution-principle.aspx">
Liskov&#39;s Substitution Principle</a><br />
4. <a href="http://social.technet.microsoft.com/wiki/contents/articles/18064.interface-segregation-principle.aspx">
Interface Segregation Principle</a><br />
5. <a href="http://social.technet.microsoft.com/wiki/contents/articles/18065.dependency-inversion-principle.aspx">
Dependency Inversion Principle</a><br />
<br />
These 5 principles are sometimes combined and regarded as SOLID Principle in object oriented design taking the initials of each of the principles. &nbsp;These makes a mark in Robert Martins categorization on Class Design Principles.<br />
<br />
<h1><a name="In_addition_to_that_there_are_also_two_more_types_of_design_principles"></a>Some other Principles</h1>
<br />
1. <a href="http://social.technet.microsoft.com/wiki/contents/articles/18067.package-cohesion-principle.aspx">
Package Cohesion Principles</a><br />
2. <a href="http://social.technet.microsoft.com/wiki/contents/articles/18068.package-coupling-principles.aspx">
Package Coupling Principles</a><br />
<br />
Software design principles are pretty much a vast topic and any developer starting developing a real world app should consider them before start of the project.&nbsp;
<br />
<br />
<h1><a name="Miscellaneous_principles_which_are_worth_mentioning"></a>Miscellaneous principles which are worth mentioning&nbsp;</h1>
<br />
<ul>
<li style="margin:0px;padding:0px;border:0px;">Program to Interface Not Implementation.
</li><li style="margin:0px;padding:0px;border:0px;">Don&#39;t Repeat Yourself. </li><li style="margin:0px;padding:0px;border:0px;">Encapsulate What Varies. </li><li style="margin:0px;padding:0px;border:0px;">Depend on Abstractions, Not Concrete classes.
</li><li style="margin:0px;padding:0px;border:0px;">Least Knowledge Principle. </li><li style="margin:0px;padding:0px;border:0px;">Favor Composition over Inheritance.
</li><li style="margin:0px;padding:0px;border:0px;">Hollywood Principle. </li><li style="margin:0px;padding:0px;border:0px;">Apply Design Pattern wherever possible.
</li><li style="margin:0px;padding:0px;border:0px;">Strive for Loosely Coupled System.
</li><li style="margin:0px;padding:0px;border:0px;">Keep it Simple and Sweet / Stupid.
</li></ul>
<br />
The principles are self explanatory.&nbsp;<br />
<br />
<h1><a name="See_Also"></a>See Also&nbsp;</h1>
<br />
<ul>
<li><a href="http://social.technet.microsoft.com/wiki/contents/articles/18030.software-patterns-practices.aspx">Software Patterns and Practices</a>
</li><li><a href="http://social.technet.microsoft.com/wiki/contents/articles/18031.design-pattern.aspx">Design Patterns</a>
</li></ul>

</div>
    
    
