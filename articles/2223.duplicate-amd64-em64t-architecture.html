---
layout: default
title: 'Duplicate&#58; AMD64 (EM64T) Architecture - TechNet Articles - United States (English) - TechNet Wiki'
weight: 3
---

<div class="post-content user-defined-markup">

<h2><a name="toc_Abstract"></a>
<p><span style="font-size:12px;"><div class="table-of-contents"><h2 class="title">Table of Contents</h2><div class="hierarchy-list-header"> </div><ul class="hierarchy-list"><li class="hierarchy-item"><a href="#toc_Abstract">Abstract</a></li><li class="hierarchy-item"><a href="#Introduction">Introduction</a></li><li class="hierarchy-item"><a href="#AMD64_architecture">1. AMD64 architecture</a><div class="hierarchy-list-header"> </div><ul class="hierarchy-list"><li class="hierarchy-item"><a href="#The_architecture_s_description">1.1. The architecture&#39;s description</a></li><li class="hierarchy-item"><a href="#The_architecture_s_advantages">1.2. The architecture&#39;s advantages</a></li><li class="hierarchy-item"><a href="#The_architecture_s_disadvantages">1.3. The architecture&#39;s disadvantages</a></li></ul><div class="hierarchy-list-footer"> </div></li><li class="hierarchy-item"><a href="#AMD64_program_model">2.AMD64 program model</a></li><li class="hierarchy-item"><a href="#Porting_applications_on_AMD64">3. Porting applications on AMD64</a></li><li class="hierarchy-item"><a href="#Conclusion">Conclusion</a></li><li class="hierarchy-item"><a href="#References">References</a></li></ul><div class="hierarchy-list-footer"> </div></div></span></p>
<span style="font-weight:bold;font-size:14px;">â€‹</span> <br />
Abstract</h2>
<p>The article briefly describes AMD64 architecture by AMD Company and its implementation EM64T by Intel Company. The architecture&#39;s peculiarities, advantages and disadvantages are described.</p>
<h2><a name="Introduction"></a>Introduction</h2>
<p>Development of computer-solved tasks demands more and more from the hardware these tasks are being solved on. The requirements to computer systems of personal-computer class have been growing year by year for 20 years already. It happens because people wish
 to solve on their personal computers more and more complex tasks which have been earlier solved only on high-performance mainframes.</p>
<p>What are these requirements to the personal computers for solving complex tasks? Of course, these are requirements of main-memory size and processor&#39;s performance (don&#39;t mix up with frequency!). IA32 architecture (Intel Architecture 32) dominating during
 the last decade offers 4Gb (2^32) of main memory of which only 2Gb are usually allocated to an application; different register blocks and sets of various tricks such as branch predication block, which should increase the system&#39;s performance without increasing
 such an abstract parameter as processor&#39;s frequency [<a href="http://www.viva64.com/go.php?url=212">1</a>].</p>
<p>Modern tasks for personal computers approach 2Gb while processors&#39; frequency increase cannot help increase performance.</p>
<p>Newly-developed 64-bit architectures SPARC64 and Intel Itanium can to some extend serve to solve the problem of modern 32-bit computers&#39; limitations. But they are intended for hi-end systems and are not available as cheap solutions. It is AMD64 architecture
 by AMD Company and its implementation EM64T by Intel Company which are to become really popular. These architectures are twins and programs compiled for one of them can be launched on the other as well. But it is the solution by AMD that historically appeared
 first. EM64T is actually only an implementation of AMD64 by Intel. AMD64 architecture is now implemented in processors of all classes: mobiles, work-stations, servers.</p>
<p>Despite evident advantages of AMD64 platform (which are described in detail in this article) it doesn&#39;t introduce anything revolutionary into computing machinery. Porting from 32 bits to 64 bits didn&#39;t lead to quality improvements while previous porting
 from 16 bits to 32 bits had increased systems&#39; safety and performance significantly.</p>
<h2><a name="AMD64_architecture"></a>1. AMD64 architecture</h2>
<p>AMD64 architecture is fully described in five documentation volumes provided by AMD Company. This chapter provides a brief description based on the first volume [<a href="http://www.viva64.com/go.php?url=213">2</a>]. Pay attention that in official documentation
 this architecture is defined as AMD x86-64 what underlines its backward compatibility.</p>
<h3><a name="The_architecture_s_description"></a>1.1. The architecture&#39;s description</h3>
<p>AMD x86-64 architecture is a simple but powerful backward-compatible extension of the obsolete industrial architecture x86 [<a href="http://www.viva64.com/go.php?url=212">1</a>]. It adds 64-bit address space and extends register resources for supporting
 more performance for recompiled 64-bit programs providing support of obsolete 16-bit and 32-bit code of applications and operational systems without modifying or recompiling them.</p>
<p>Necessity of <a href="http://www.viva64.com/terminology/64-bit.html">64-bit</a> x86 architecture is explained by applications which need large address space. These are high-performance servers, data managers, CAD-systems and of course games. Such applications
 will gain an advantage due to 64-bit address space and more registers. Few registers available in obsolete x86 architecture limit computing-task performance. More registers provide sufficient performance for most applications.</p>
<p>x86-64 architecture introduces two new peculiarities:</p>
<p>1. Extended registers (Picture 1):</p>
<ul>
<li>8 general-purpose registers; </li><li>all 16 general-purpose registers are 64-bit; </li><li>8 new 128-bit XMM registers; </li><li>a new command prefix (REX) for access to extended registers. </li></ul>
<p>2. special mode &quot;Long Mode&quot; which is shown in Table 1:</p>
<ul>
<li>up to 64-bit virtual addresses; </li><li>64-bit command pointer (RIP); </li><li>flat address space. </li></ul>
<p><a target="_blank" href="http://social.technet.microsoft.com/wiki/contents/articles/amd64_em64t/image2.png"></a></p>
<a target="_blank" href="http://social.technet.microsoft.com/wiki/contents/articles/amd64_em64t/image2.png">
<p>&nbsp;<img alt=" " src="http://social.technet.microsoft.com/wiki/resized-image.ashx/__size/550x0/__key/CommunityServer-Wikis-Components-Files/00-00-00-00-05/4861.image2.png" style="border:0px solid;" /></p>
</a>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><em>Picture 1. Set of x86-64 registers</em></p>
<p><a target="_blank" href="http://social.technet.microsoft.com/wiki/contents/articles/amd64_em64t/image4.png"></a></p>
<a target="_blank" href="http://social.technet.microsoft.com/wiki/contents/articles/amd64_em64t/image4.png">
<p><img alt=" " src="http://social.technet.microsoft.com/wiki/resized-image.ashx/__size/550x0/__key/CommunityServer-Wikis-Components-Files/00-00-00-00-05/7838.image4.png" style="border:0px solid;" /></p>
</a>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><em>Table 1. Processor operating modes.</em></p>
<p>Table 2 contains comparison of registers&#39; and stack&#39;s resources available to an application in different modes. Left columns show resources provided by obsolete x86 architecture which are available only to compatibility. Right columns show resources available
 in 64-bit mode. The difference between the modes is marked grey.</p>
<p><a target="_blank" href="http://social.technet.microsoft.com/wiki/contents/articles/amd64_em64t/image6.png"></a></p>
<a target="_blank" href="http://social.technet.microsoft.com/wiki/contents/articles/amd64_em64t/image6.png">
<p><img alt=" " src="http://social.technet.microsoft.com/wiki/resized-image.ashx/__size/550x0/__key/CommunityServer-Wikis-Components-Files/00-00-00-00-05/7028.image6.png" style="border:0px solid;" /></p>
</a>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><em>Table 2. Registers and stack available in different modes</em></p>
<p>As shown in Table 2 obsolete x86 architecture (this mode is called legacy mode in x86-64) supports 8 general-purpose registers. But actually only 4 registers (EBP, ESI, EDI, ESP) are usually used as they are of special purpose. X86-64 architecture adds 8
 general-purpose registers and enlarges the register range from 32 bits to 64 bits. It allows compilers to increase code performance. A 64-bit compiler can use registers for storing variables more efficiently. The compiler also allows you to minimize memory
 access by locating operation inside general-purpose registers.</p>
<ul>
<li>x86-64 architecture supports the whole set of x86 instructions and adds some new instructions for supporting long-mode. The commands are divided into several subsets:
</li><li>General-purpose commands. These are main x86 integer commands used in all programs. Most of them are intended for loading, saving and processing data located in general-purpose registers or memory. Some of these commands manage the command stream providing
 passage from one program section to another. </li><li>128-bit media-commands. These are SSE and SSE2 (streaming SIMD extension) commands intended for loading, saving or processing data located in 128-bit XMM registers. They perform integer or floating-point operations over vector (packed) and scalar data types.
 As vector commands can perform one operation over a data set independently they are called single-instruction, multiple-data (SIMD) commands. They are used for media- and science applications for processing data blocks.
</li><li>64-bit media-commands. These are multimedia extension (MMX) and 3DNow! Commands. They save, restore and process data located in 64-bit MMX registers. Like 128-bit commands described before they perform integer and floating-point operations over vector (packed)
 and scalar data. </li><li>x87 commands. They are intended for working with the floating point in obsolete x87 applications. They process data in x87 registers.
</li></ul>
<p>Some of these commands connect two or more subsets of the commands described above. For example, such are commands of data transmission between general-purpose registers and XMM or MMX registers.</p>
<p>Let&#39;s consider in detail the operating modes shown in Table 1 supported by x86-64. In most cases addresses&#39; and operands&#39; sizes can be overlayed by a command prefix.</p>
<p>Let&#39;s describe long-mode at first. This is an extension of the obsolete protected mode. Long-mode consists of two submodes: 64-bit mode and compatibility mode. 64-bit mode supports all the new possibilities and register extensions introduced into x86-64.
 Compatibility mode supports binary compatibility with existing 16-bit and 32-bit code. Long-mode doesn&#39;t support obsolete real mode or obsolete virtual-8086 mode and it also doesn&#39;t support hardware task switching.</p>
<p>As 64-bit mode supports 64-bit address space you need to use a new 64-bit operational system for its work. Meanwhile, the existing applications can be launched without recompiling in compatibility mode under the OS working in 64-bit mode. For 64-bit command
 addressing a 64-bit register (RIP) and a new addressing mode with single flat address space for code, stack and data are used.</p>
<p>64-bit mode implements support of extended registers through a new prefix group of REX commands.</p>
<p>In 64-bit mode addresses&#39; size is 64 bits on default but implementations of x86-64 may have a smaller size. An operand&#39;s size is 32 bits on default. For most instructions the operand&#39;s size can be overlaid using a prefix of REX-type commands.</p>
<p>64-bit mode provides data addressing relative to the 64-bit register RIP. X86 architecture provided addressing relative to IP register only in control transfer commands. RIP-relative addressing increases efficiency of position-independent code and code addressing
 global data.</p>
<p>Some opcode commands were redefined to support extended registers and 64-bit addressing.</p>
<p>Compatibility mode is intended for executing existing 16-bit and 32-bit programs in a 64-bit OS. Applications are launched in compatibility mode with the use of 32- or 16-bit address space and can have access to 4Gb of virtual address space. Commands&#39; prefixes
 can switch 16- and 32-bit addresses and operands&#39; sizes.</p>
<p>From the application&#39;s viewpoint compatibility mode looks like the obsolete protected x86 mode but from the viewpoint of the OS (address translation, processing of interruptions and exceptions) 64-bit mechanisms are used.</p>
<p>Legacy mode provides binary compatibility not only with 16- and 32-bit applications but with 16- and 32-bit operational systems as well. It includes three modes:</p>
<ul>
<li>Protected mode. 16- and 32-bit programs with segmental memory organization, privilege and virtual memory support. Address space is 4Gb.
</li><li>Virtual-8086 mode. Supports 16-bit applications launched as tasks in protected mode. Address space is 1Mb.
</li><li>Real mode. Supports 16-bit programs with simple register addressing of segmented memory. Virtual memory and privileges are not supported. 1Mb of memory is available.
</li></ul>
<p>Legacy mode is used only when 16- and 32-bit OS are operating.</p>
<h3><a name="The_architecture_s_advantages"></a>1.2. The architecture&#39;s advantages</h3>
<p>Let&#39;s outline the main advantages of AMD x86-64 architecture.</p>
<ul>
<li>64-bit address space. </li><li>Extended register set. </li><li>Developer-habitual command set. </li><li>Possibility of launching obsolete 32-bit applications in a 64-bit OS. </li><li>Possibility of using a 32-bit OS. </li></ul>
<h3><a name="The_architecture_s_disadvantages"></a>1.3. The architecture&#39;s disadvantages</h3>
<p>The new architecture AMD x86-64 hasn&#39;t introduced crucial disadvantages into 32-bit architecture. We can point out only a bit increased programs&#39; memory requirements because of the larger size of addresses and operands. But it won&#39;t influence however significantly
 the code size or the requirements to available main memory.</p>
<p>But the fact is that AMD x86-64 hasn&#39;t introduced anything significantly new. There is no performance gain. On the average, you can expect 5-15% performance gain after recompiling a program.</p>
<h2><a name="AMD64_program_model"></a>2.AMD64 program model</h2>
<p>Nearly all modern OS now have versions for AMD64 architecture. Thus, Microsoft presents Windows XP 64-bit, Windows Server 2003 64bit, Windows Vista 64bit. The leading UNIX system developers also provide 64-bit versions, such as, for example, Linux Debian
 3.1 x86-64. But it doesn&#39;t mean that the whole code of such a system is completely 64-bit. Some OS code and many applications still can remain 32-bit as AMD64 provides backward compatibility.</p>
<p>64-bit Windows version, for example, uses a special mode WoW (Windows-on-Windows 64) which translates 32-bit applications&#39; calls to the resources of a 64-bit OS. Let&#39;s consider in detail AMD64 program model available to a programmer in 64-bit Windows [<a href="http://www.viva64.com/go.php?url=214">3</a>,
<a href="http://www.viva64.com/go.php?url=215">4</a>] shortly called Win64.</p>
<p>Let&#39;s begin with address space. Although a 64-bit processor can theoretically address 16 exabyte (2^64) Win64 now supports 16 terabytes (2^44). There are several reasons for this. Existing processors can provide access only to 1 terabyte (2^40) of actual
 storage. The architecture (but not the hardware part) can extend this space up to 4 petabytes. But anyway we need a great memory size for page tables representing memory. (see Table 3).</p>
<table>
<tbody>
<tr>
<td><br />
</td>
<td><strong>32-bit mode</strong></td>
<td><strong>64-bit mode</strong></td>
</tr>
<tr>
<td>Process&#39;s general address space</td>
<td>4Gb</td>
<td>16Tb</td>
</tr>
<tr>
<td>Address space available to a 32-bit process</td>
<td>2Gb (3Gb if the system is loaded with /3GB key)</td>
<td>4Gb if the application is compiled with /LARGEADDRESSAWARE key (2Gb otherwise)</td>
</tr>
<tr>
<td>Address space available to a 64-bit process</td>
<td>Impossible</td>
<td>8Tb</td>
</tr>
<tr>
<td>Paged pool</td>
<td>470Mb</td>
<td>128Gb</td>
</tr>
<tr>
<td>Non-paged pool</td>
<td>256Mb</td>
<td>128Gb</td>
</tr>
<tr>
<td>System Page Table (PTE)</td>
<td>660Mb - 900Mb</td>
<td>128Gb</td>
</tr>
</tbody>
</table>
<p><em>Table 3. Main memory limitations in Windows</em></p>
<p>Like in Win32 the addressed memory range is divided into user and system addresses. Each process receives 8Tb and 8Tb remain in the system (unlike 2Gb and 2Gb in Win32 correspondingly). Different Windows versions have different limitations shown in Table
 4.</p>
<table>
<tbody>
<tr>
<td><strong>Actual storage and number of processors</strong></td>
<td><strong>32-bit models</std>Address space available to a 32-bit process</td>
<td>2Gb (3Gb if the system is loaded with /3GB key)</td>
<td>4Gb if the application is compiled with /LARGEADDRESSAWARE key (2Gb otherwise)</td>
</tr>
<tr>
<td>Address space available to a 64-bit protrong></td>
<td><strong>64-bit models</strong></td>
</tr>
<tr>
<td>Windows XP Home</td>
<td>4 Gb, 1 CPU</td>
<td>Not present</td>
</tr>
<tr>
<td>Windows XP Professional</td>
<td>4 Gb, 1-2 CPU</td>
<td>128 Gb, 1-2 CPU</td>
</tr>
<tr>
<td>Windows Server 2003, Standard</td>
<td>4 Gb, 1-4 CPU</td>
<td>32 Gb, 1-4 CPU</td>
</tr>
<tr>
<td>Windows Server 2003, Enterprise</td>
<td>64 Gb, 1-8 CPU</td>
<td>1 Tb, 1-8 CPU</td>
</tr>
<tr>
<td>Windows Server 2003, Datacenter</td>
<td>64 Gb, 8-32 CPU</td>
<td>1 Tb, 8-64 CPU</td>
</tr>
<tr>
<td>Windows Server 2008, Datacenter</td>
<td>64 Gb, 2-64 CPU</td>
<td>2 Tb, 2-64 CPU</td>
</tr>
<tr>
<td>Windows Server 2008, Enterprise</td>
<td>64 Gb, 1-8 CPU</td>
<td>2 Tb, 1-8 CPU</td>
</tr>
<tr>
<td>Windows Server 2008, Standard</td>
<td>4 Gb, 1-4 CPU</td>
<td>32 Gb, 1-4 CPU</td>
</tr>
<tr>
<td>Windows Server 2008, Web Server</td>
<td>4 Gb, 1-4 CPU</td>
<td>32 Gb, 1-4 CPU</td>
</tr>
<tr>
<td>Vista Home Basic</td>
<td>4 Gb, 1 CPU</td>
<td>8 Gb, 1 CPU</td>
</tr>
<tr>
<td>Vista Home Premium</td>
<td>4 Gb, 1-2 CPU</td>
<td>16 Gb, 1-2 CPU</td>
</tr>
<tr>
<td>Vista Business</td>
<td>4 Gb, 1-2 CPU</td>
<td>128 Gb, 1-2 CPU</td>
</tr>
<tr>
<td>Vista Enterprise</td>
<td>4 Gb, 1-2 CPU</td>
<td>128 Gb, 1-2 CPU</td>
</tr>
<tr>
<td>Vista Ultimate</td>
<td>4 Gb, 1-2 CPU</td>
<td>128 Gb, 1-2 CPU</td>
</tr>
</tbody>
</table>
<p><em>Table 4. Limitations of different Windows versions</em></p>
<p>Like in Win32 a page&#39;s size is 4Kb. First 4Kb of address space are never shown, i.e. the least true address is 0x10000. Unlike Win32 system DLL are loaded exceeding 4Gb.</p>
<p>All the processors implementing AMD64 have support for &quot;CPU No Execution&quot; bit which is used by Windows for implementing the hardware technology &quot;Data Execution Protection&quot; (DEP) which forbids execution of user data instead of code. It allows you to increase
 programs&#39; safety excluding influence of such errors as execution of the buffer with data as code.</p>
<p>The peculiarity of AMD64 compilers is that they can most efficiently implement registers for passing parameters into functions instead of using the stack. It allowed Win64 architecture developers to get rid off such a notion as calling convention. In Win32
 you can use different conventions (ways of passing parameters): __stdcall, __cdecl, __fastcall etc. In Win64 there is only one calling convention. Let&#39;s consider an example of how four arguments of integer-type are passed in registers:</p>
<ul>
<li>RCX: first argument </li><li>RDX: second argument </li><li>R8: third argument </li><li>R9: fourth argument </li></ul>
<p>Arguments after the first four integers are passed on the stack. For float arguments XMM0-XMM3 both the registers and the stack are used.</p>
<p>The difference in calling conventions leads to that you cannot use both 64-bit and 32-bit code in one program. In other words, if an application is compiled for 64-bit mode all the used DLL libraries must be 64-bit too.</p>
<p>While writing 64-bit code you can get additional performance gain thanks to special optimization. This question is considered in detail in optimizing instructions [<a href="http://www.viva64.com/go.php?url=59">5</a>].</p>
<h2><a name="Porting_applications_on_AMD64"></a>3. Porting applications on AMD64</h2>
<p>One of the purposes of high-level languages is to reduce as far as possible the binding of program code to the architecture and provide the most possible portability between hardware platforms. For example, C&#43;&#43; programs written correctly are theoretically
 independent from the hardware platform. And, ideally, to compile the corresponding 32-bit applications for AMD64 platform it is enough only to change the compiler [<a href="http://www.viva64.com/go.php?url=488"> 6</a>] and just recompile the program. But in
 practice everything is more complicated.</p>
<p>Software using Assembler code for 32-bit processors still exists. Many programs written in high-level languages contain Assembler blocks. That&#39;s why it is often impossible just to recompile a large project. The solution of this problem is clear. Firstly,
 you can refuse porting an application on a new platform. It can be a very reasonable solution because, for example, Windows-family OS provide good backward compatibility due to Wow64 technology. The second variant is to rewrite the program code. Moreover,
 it seems reasonable to rewrite it using high-level languages. By the way, pay attention that Visual C&#43;&#43; compiler doesn&#39;t support compilation of Assembler blocks in 64-bit compilation mode anymore [<a href="http://www.viva64.com/go.php?url=217">7</a>].</p>
<p>Presence of Assembler program code is not the only obstacle we face while mastering 64-bit systems. While porting programs on 64-bit systems different errors occur relating to changing of the data model (type dimension). What&#39;s more, some errors become apparent
 only while using large memory size which was unavailable in 32-bit systems. Such errors are well described in the article &quot;20 issues of porting C&#43;&#43; code on the 64-bit platform&quot; [<a href="http://www.viva64.com/art-1-2-599168895.html">8</a>].</p>
<p>All said above relates mostly to C/C&#43;&#43; applications. It is better with managed code (C#) although we can face some small problems here as well. Unfortunately, large program complexes are often built using libraries written in C/C&#43;&#43;. And that&#39;s why in case
 of a large C# project it most likely contains C/C&#43;&#43; modules or libraries which can be unsafe and contain vulnerabilities.</p>
<p>For testing and checking program code ported on a 64-bit platform you can use different special methods and tools [<a href="http://www.viva64.com/art-1-2-1289354852.html">9</a>]. For example, such static analyzers as
<a href="http://www.viva64.com/viva64-tool/">Viva64</a> (for Windows systems) and
<a target="_blank" href="http://www.gimpel.com/">PC-Lint</a> (for Unix systems) can provide good results. To learn more about this toolkit read the article &quot;Comparison of analyzers&#39; diagnostic abilities while testing 64-bit code&quot; [<a href="http://www.viva64.com/art-1-2-914146540.html">10</a>].</p>
<h2><a name="Conclusion"></a>Conclusion</h2>
<p>Undoubtedly, AMD64 architecture offered by AMD Company turned out to be needed on market. AMD64&#39;s advantage is that it allows you to smoothly switch to 64-bit programs without losing compatibility with obsolete 32-bit applications. But there is nothing revolutionary
 in AMD64.</p>
<p>Migration of 32-bit programs on AMD64, as experiments demonstrate, allows you, firstly, to solve tasks which are much more memory-demanding and, secondly, get abo href="http://www.viva64.com/art-1-2-1289354852.html">9</a>]. For example, such static analyzers as
<a href="http://www.viva64.com/viva64-tool/">Viva64</a> (for Windows ut 10% performance gain &quot;just so&quot; without changing code due to optimization of an application
 by the compiler for the new architecture.</p>
<p>We may conclude that AMD64 architecture postponed the problem of limited available main-memory size for many years but didn&#39;t solve the problem of modern personal computers&#39; performance gain. The future is still with multi-core and multi-processor systems.</p>
<h2><a name="References"></a>References</h2>
<ol style="list-style-type:decimal;">
<li>Intel Software Developer&#39;s Manual. Volume 1: Basic Architecture. <a href="http://www.viva64.com/go.php?url=212">
http://www.viva64.com/go.php?url=212</a> </li><li>AMD x86-64 Architecture Programmer&#39;s Manual. Volume 1: Application Programming.
<a href="http://www.viva64.com/go.php?url=213">http://www.viva64.com/go.php?url=213</a>
</li><li>Mike Wall. Tricks for Porting Applications to 64-Bit Windows on AMD64 Architecture.
<a href="http://www.viva64.com/go.php?url=214">http://www.viva64.com/go.php?url=214</a>
</li><li>Matt Pietrek. Everything You Need To Know To Start Programming 64-Bit Windows Systems.
<a href="http://www.viva64.com/go.php?url=215">http://www.viva64.com/go.php?url=215</a>
</li><li>Software Optimization Guide for AMD Athlon 64 and AMD Opteron Processors. <a href="http://www.viva64.com/go.php?url=59">
http://www.viva64.com/go.php?url=59</a> </li><li>Compiler Usage Guidelines for 64-Bit Operating Systems on AMD64 Platforms. <a href="http://www.viva64.com/go.php?url=216">
http://www.viva64.com/go.php?url=216</a> </li><li>Daniel Pistelli. Moving to Windows Vista x64. <a href="http://www.viva64.com/go.php?url=217">
http://www.viva64.com/go.php?url=217</a> </li><li>Andrey Karpov, Evgeniy Ryzhkov. 20 issues of porting C&#43;&#43; code on the 64-bit platform.
<a href="http://www.viva64.com/art-1-2-599168895.html">http://www.viva64.com/art-1-2-599168895.html</a>
</li><li>Andrey Karpov. Problems of testing 64-bit applications. <a href="http://www.viva64.com/art-1-2-1289354852.html">
http://www.viva64.com/art-1-2-1289354852.html</a> </li><li>Andrey Karpov. Comparison of analyzers&#39; diagnostic abilities while testing 64-bit code.
<a href="http://www.viva64.com/art-1-2-914146540.html">http://www.viva64.com/art-1-2-914146540.html</a>
</li></ol>

</div>
    
    
